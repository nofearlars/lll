import React from 'react'
import _ from 'lodash'
import { Transforms, Editor, T } from 'slate'
import { Editable, ReactEditor, useSlate, useSelected } from 'slate-react'
import { getVariableType, typeMap, TypeIcon } from '../utils'
import { CloseOutlined } from '@ant-design/icons'
import { useRecoilValue, useSetRecoilState } from 'recoil'
import { formulaAtom, varAndFunAtom, selectAtom, isFormulaAtom, stringifyAtom, isSelectFormulaAtom } from '../store'
import { getEditorValue } from '../utils/parseAndStringify'

// 默认节点
const DefaultElement = props => {
  return <span {...props.attributes}>{props.children}</span>
}
// 变量节点
const VariableElement = (props) => {
  const { attributes, element } = props
  const { variable } = element
  const type = variable.type === 'array' ? 'array' : variable.defineSchema.nodeType || variable.defineSchema.type
  const selected = useSelected()

  const typeItem = typeMap[type] || typeMap['object']

  return <span {...attributes} className="tag-element" style={{ backgroundColor: selected ? `${typeItem?.color}50` : `${typeItem?.color}10`, border: `1px solid ${typeItem?.color}`, color: typeItem.color }}>
    <div className='tag-element-flex'>
      <span style={{ paddingRight: '6px' }}>{variable.title.split('.').map(item => _t1(item)).join('.')}</span>
      <span style={{ display: 'inline-block' }}>
        <TypeIcon type={type} />
      </span>
    </div>
    
    {props.children}
  </span>
}

// 公式节点
const FormulaElement = (props) => {

  const { attributes, element } = props

  const selected = useSelected()

  const setSelectFormula = useSetRecoilState(isSelectFormulaAtom)

  React.useEffect(() => {
    setSelectFormula(selected)
  }, [ selected ])

  return <span {...attributes} className="formula-element">{props.children}</span>
}

// 公式编辑器
const Formula = React.forwardRef((props, rootRef) => {

  const { t:_t1 } = useI18n()

  const { onForceChange } = props

  const value = useRecoilValue(formulaAtom)
  const setVarAndFun = useSetRecoilState(varAndFunAtom)
  const select = useRecoilValue(selectAtom)
  const stringify = useRecoilValue(stringifyAtom)
  const isFormula = useRecoilValue(isFormulaAtom)
  const isSelectFormula = useRecoilValue(isSelectFormulaAtom)
  const setIsSelectFormula = useSetRecoilState(isSelectFormulaAtom)

  const readOnly = select === 'single'

  // 编辑器实例
  const editor = useSlate()
  // 获取当前变量及函数信息
  const [ varAndFun, setVarAndFunInner ] = useVarAndFun(editor)
  // 插入或者替换变量
  const insertVariable = ({ variable }) => {
    
    const location = varAndFun?.variableLocation || editor.selection
    // 判断该位置是否有变量
    let variableLocation = null
    const currentVariable = _util.getVariableNode(editor, location )
    if (!currentVariable) {
      Transforms.insertNodes(editor, { type: 'variable', children: [{ text: '' }], variable}, { at: location,  select: true })
    } else {
      Transforms.setNodes(editor, { variable }, { match: n => n.type === 'variable', at: location || editor.selection, select: true })
      variableLocation = location
    }
    if (!readOnly) {
      setVarAndFunInner({
        ..._.cloneDeep(varAndFun),
        variable,
        variableLocation
      })
      ReactEditor.focus(editor)
    }
  }

  // 插入函数
  const insertFunction = ({ text }) => {
    const location = varAndFun.functionLocation || editor.selection
    Transforms.insertText(editor, `${text}()`, { at: location })
    ReactEditor.focus(editor)
    Transforms.move(editor, { distance: 1, reverse: true })
  }
  // 插入文本函数
  const insertWordFunction = ({ text }) => {
    const location = varAndFun.wordLocation || editor.selection
    Transforms.insertText(editor, `${text}()`, { at: location })
    ReactEditor.focus(editor)
    Transforms.move(editor, { distance: 1, reverse: true })
  }
  // 插入文本
  const insertText = ({ text }) => {
    const location = varAndFun.functionLocation || editor.selection
    Transforms.insertText(editor, `${text} `, { at: location })
    ReactEditor.focus(editor)
  }
  // 插入公式
  const insertFormula = () => {
    const location = varAndFun?.variableLocation || editor.selection
    Transforms.insertNodes(editor, [{ type: 'formula', children: [{ text: '' }]}, { text: '' }], { at: location })
  }
  // 删除清空
  const clear = () => {
    onForceChange && onForceChange(null)
    setTimeout(() => {
      setVarAndFun({
        variable: null
      })
      setIsSelectFormula(false)
    }, 300)
  }
  const setValue = (value) => {
    if (value && value.length){
      editor.children = value
    }
  }
  const focus = () => {
    ReactEditor.focus(editor)
  }
  // 暴露方法
  React.useImperativeHandle(rootRef, () => ({ insertVariable, insertFunction, insertWordFunction, insertText, insertFormula, clear, setValue, focus }))
  // 节点渲染方法
  const renderElement = props => {
    switch (props.element.type) {
      case 'variable':
        return <VariableElement {...props} />
      case 'formula':
        return <FormulaElement {...props} />
      default:
        return <DefaultElement {...props} />
    }
  }
  // 监听选中变量的变化
  React.useEffect(() => {
    setVarAndFun(varAndFun)
    // onSelectVarAndFun && onSelectVarAndFun(varAndFun)
  }, [ JSON.stringify(varAndFun) ])

  return (
    <div className="iot-editor-slate" style={{ width: '100%', height: '100%', padding: '0 10px' }}>
      <Editable placeholder={isFormula ? _t1('请输入公式，语法为JavaScript') : _t1('请选择变量')} renderElement={renderElement} onKeyDown={event => {
        if (select && !isSelectFormula && ['Backspace', 'ArrowRight', 'ArrowLeft'].indexOf(event.key) === -1) {
          event.preventDefault()
        }
        if (event.key === 'Enter') {
          event.preventDefault()
        }
      }} />
      {
        readOnly && _util.isVariableEmpty(value?.origin) ? (
          <div className="iot-editor-slate-close" onClick={clear} style={{ cursor: 'pointer' }}>
            <CloseOutlined />
          </div>
        ) : null
      }
    </div>
  )
})

// 获取当前选中变量及函数的hook
const useVarAndFun = (editor) => {

  const isFormula = useRecoilValue(isFormulaAtom)

  // 构建我们需要的对象
  const [ varAndFun, setVarAndFun ] = React.useState({
    variable: null, // 变量
    variableLocation: null, // 变量位置
    functionText: null, // 函数名
    functionLocation: null // 函数名位置
  })

  React.useEffect(() => {
    const $varAndFun = {
      variable: null, // 变量
      variableLocation: null, // 变量位置
      functionText: null, // 函数名
      functionLocation: null // 函数名位置
    }
    if (editor.selection) {
      // 当前选中的变量，未选中为null
      const selectVariable = _util.getVariableNode(editor)
      // 如果选中的就是变量
      if (selectVariable) {
        $varAndFun.variable = selectVariable,
        $varAndFun.variableLocation = editor.selection
      // 如果不是变量
      } else {
        // 当前文本节点的初始位置
        const startPoint =  _.cloneDeep(editor.selection.focus)
        startPoint.offset = 0
        // 当前节点光标前整段文本
        const allText = _util.getString(editor, {
          anchor: editor.selection.anchor,
          focus: startPoint
        })
        // .的位置
        const isInFormula = isFormula || editor.selection?.focus?.path?.length === 3
        if (isInFormula) {
          const dotOffset = allText?.lastIndexOf('.')
          // 如果有.字符
          if ((dotOffset || dotOffset === 0) && dotOffset !== -1) {
            const dotPoint = _.cloneDeep(editor.selection.focus)
            const afterDotPonit = _.cloneDeep(editor.selection.focus)
            // 获取.后的函数名和位置
            dotPoint.offset = dotOffset
            afterDotPonit.offset = dotOffset + 1
            const functionlocation = {
              anchor: afterDotPonit,
              focus: editor.selection.focus
            }
            $varAndFun.functionText = _util.getString(editor, functionlocation)
            $varAndFun.functionLocation = functionlocation
            // 获取.前的内容
            const before = Editor.before(editor, { anchor: dotPoint, focus: dotPoint})
            const beforeVariable = _util.getVariableNode(editor, {anchor: before, focus: before})
            // 如果.前是个变量节点
            if (beforeVariable) {
              $varAndFun.variable = beforeVariable
              $varAndFun.variableLocation = $varAndFun.functionText ? editor.selection : {anchor: before, focus: before}
            }
          }
          const operators = ['+', '-', '*', '/', '%', '&&', '||', '!', '==', '!=', '===', '!==', '>', '>=', '<', '<='];
          let operatorOffset = -1

          for (const op of operators) {
            const offset = allText?.lastIndexOf(op)
            if ( offset > operatorOffset) {
              operatorOffset = offset
            }
          }
          const afterOperator = _.cloneDeep(editor.selection.focus)
          afterOperator.offset = operatorOffset + 1
          const wordLocation = {
            anchor: afterOperator,
            focus: editor.selection.focus
          };

          $varAndFun.wordText = _util.getString(editor, wordLocation);
          $varAndFun.wordLocation = wordLocation;
        }
      }
    }
    setVarAndFun($varAndFun)

  }, [ editor.selection ])

  return [ varAndFun, setVarAndFun ]
}
// 工具函数
const _util = {
  // 获取某一位置的文本
  getString (editor, location) {
    const result = editor.selection && Editor.string(editor, location)
    return result
  },
  // 获取某一位置的变量
  getVariableNode (editor, location=editor.selection) {
    const [ selectVariable ] = Editor.nodes(editor, { match: n => n.type === 'variable', at: location })
    if(selectVariable) {
      return selectVariable[0]?.variable
    }
    return null
  },
  // value是否为空
  isVariableEmpty (value) {
    if (value && value.length) {
      for (let item of value) {
        if (item?.type) {
          return true
        }
      }
    }
    return false
  }
}

export default Formula
