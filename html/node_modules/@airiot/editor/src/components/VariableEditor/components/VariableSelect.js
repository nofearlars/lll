import React from 'react'
import _ from 'lodash'
import { Breadcrumb, Spin, Tooltip } from 'antd'
import {getVariableByPath, getPathLast, getVariableType, typeMap, TypeIcon } from '../utils'
import doc, { createDescription } from '../utils/doc'
import { useRecoilValue, useSetRecoilState } from 'recoil'
import { expectedSelector, varAndFunAtom, nodeTypeAtom, limitAtom, hasLoadingAtom, finalSchemaSelector, selectAtom, isFormulaAtom, stringifyAtom, isSelectFormulaAtom, functionSchemaSelector, errorAtom, attrSchemaSelector } from '../store'
import { getEditorValue } from '../utils/parseAndStringify'

// 根据path获取变量列表
const getVariablesSchemaList = async (schema, varAndFun, limit, querySchema) => {
  let subSchema = schema
  const parentVariable = varAndFun.variable
  let { path: parentPath, type: parentType, title: parentTitle, lastType }  = parentVariable || {}
  // 如果有函数名片段
  if (varAndFun.functionText) {
    // 如果能搜到值
    if (getFunList(parentType, varAndFun.functionText)?.length) {
      return []
    } else {
      parentPath = null
      parentType = null
      parentTitle = null
    }
  // 如果没有函数名片段
  } else {
    if (parentPath) {
      subSchema = getVariableByPath(schema, parentPath)
      if (querySchema && subSchema.loading) {
        const properties = await querySchema(subSchema, parentVariable)
        subSchema.properties = {
          ...subSchema.properties,
          ...properties
        }
        subSchema.loading = false
      }
    }
  }
  const keys = _.keys(subSchema?.properties) || []
  return keys.map(key => {
    const defineSchema = _.cloneDeep(subSchema.properties[key])
    if (defineSchema.type === 'string' && defineSchema.format) {
      defineSchema.type = 'time'
    }
    delete defineSchema.properties
    return {
      path: parentPath ? `${parentPath}.${ lastType === 'array' ? '#.' : '' }${key}` : key,
      type: parentType ? `${parentType}.${defineSchema.type}` : defineSchema.type,
      title: parentTitle ? `${parentTitle}.${defineSchema.title || key}` : defineSchema.title || key,
      defineSchema,
      key
    }
  })
  .filter((item) => {
    if (limit) {
      if (item.defineSchema.type === 'object') {
        return true
      }
      if (_.isArray(limit) && limit.length) {
        if (limit.indexOf(item.defineSchema.type) !== -1 || limit.indexOf(item.defineSchema.nodeType) !== -1) {
          return true
        } else {
          return false
        }
      }
      if (_.isFunction(limit)) {
        return limit({ defineSchema: item.defineSchema })
      }
      return true
    } else {
      return true
    }
  })
}

const getFunList = (parentType, functionText) => {
  if (!parentType) {
    return []
  } else {
    const list = Object.getOwnPropertyNames(typeMap[parentType].Creator.prototype).filter(name => {
      return name.indexOf(functionText) !== -1 && name !== 'constructor' && !/^__/.test(name)
    })
    return list
  }
}

const VariableBreadcrumb = ({ parentVariable, onClick }) => {
  const { title: parentTitle='', path: parentPath, type: parentType } = parentVariable || {}

  const [ breadTitle, setBreadTitle ] = React.useState(null)

  const onClickBread = (index) => {
    if (index === '变量列表') {
      setBreadTitle('变量列表')
      onClick && onClick({
        variable: null
      })
    } else {
      const pathList = parentPath.split('.')
      const typeList = parentType.split('.')
      const titleList = parentTitle.split('.')
      const path = pathList.splice(0, index+1).join('.')
      const type = typeList.splice(0, index+1).join('.')
      const title = titleList.splice(0, index+1).join('.')
      setBreadTitle(title)
      onClick && onClick({
        variable: {
          path,
          type,
          title
        }
      })
    }
  }

  React.useEffect(() => {
    setBreadTitle('')
  }, [ parentTitle ])

  return (
    <div className="select-panel-breadcrumb">
      <Breadcrumb>
        <Breadcrumb.Item onClick={() => { onClickBread('变量列表') }}>
          <a>{_t1('变量列表')}</a>
        </Breadcrumb.Item>
        {
          breadTitle === '变量列表' ? null : (breadTitle || parentTitle).split('.').map((title, index) => <Breadcrumb.Item onClick={() => { onClickBread(index) }}>
            <a style={{ display: 'inline-block', maxWidth: '100px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{_t1(title)}</a>
          </Breadcrumb.Item>)
        }
      </Breadcrumb>
    </div>
  )
}

const VariableSelect = (props) => {

  const { editorRef, onFull, onForceChange, querySchema, customStringify } = props

  const schema = useRecoilValue(finalSchemaSelector)
  const expected = useRecoilValue(expectedSelector)
  const varAndFun = useRecoilValue(varAndFunAtom)
  const nodeType = useRecoilValue(nodeTypeAtom)
  const limit = useRecoilValue(limitAtom)
  const hasLoading = useRecoilValue(hasLoadingAtom)
  const select = useRecoilValue(selectAtom)
  const setVarAndFun = useSetRecoilState(varAndFunAtom)
  const isFormula = useRecoilValue(isFormulaAtom)
  const stringify = useRecoilValue(stringifyAtom)
  const isSelectFormula = useRecoilValue(isSelectFormulaAtom)
  const functionSchema = useRecoilValue(functionSchemaSelector)
  const attrSchema = useRecoilValue(attrSchemaSelector)
  const error = useRecoilValue(errorAtom)

  const { type: parentType, title: parentTitle='' }  = varAndFun?.variable || {}

  const [ schemaActive, setSchemaActive ] = React.useState(null)
  const [ breadvariable, setBreadvariable ] = React.useState(null)
  const [ currentList, setCurrentList ] = React.useState([])

  // 编辑器插入值
  const onSelect = (item) => {
    if (item.insert) {
      if ( select && !isSelectFormula ) {
        onForceChange(getEditorValue([{
          type: 'variable',
          children: [{ text: '' }],
          variable: item.variable
        }], stringify, customStringify))
        setTimeout(() => {
          setVarAndFun({ variable: item.variable})
        }, 300)
      } else {
        if (item.type === 'variable') {
          editorRef.current.insertVariable({ variable: item.variable }) 
        } else if (item.type === 'function') {
          editorRef.current.insertFunction({ text: item.name })
        } else if (item.type === 'wordFunction') {
          editorRef.current.insertWordFunction({ text: item.name })
        } else if (item.type === 'attr') {
          editorRef.current.insertText({ text: item.name })
        }
      }
    } else {
      setVarAndFun({ variable: item.variable})
    }
    if (item.close) {
      // setShow(false)
    }
  }

  const onInsertFormula = () => {
    if ( select === 'single' ) {
      onForceChange(getEditorValue([{ type: 'formula', children: [{ text: ' ' }]}, { text: ' ' }], stringify, customStringify))
    } else {
      editorRef.current.insertFormula({ text: '' })
    }
  }

  const clickItem = (item, type) => {
    if (type === 'variable') {
      const { type: vType, lastType } = getVariableType(item)
      item.type = vType
      item.lastType = lastType
      const con1 = _.isArray(limit) && limit.length && limit.indexOf(item.defineSchema.type) !== -1
      const con2 = _.isFunction(limit) && limit({ defineSchema: item.defineSchema })
      const payload = {
        type,
        variable: item,
        insert: nodeType ? item.defineSchema.nodeType === nodeType : true,
        close: item.defineSchema.type !== 'object' && item.defineSchema.type !== 'array'
      }
      if (!_.isUndefined(item.defineSchema.insert)) {
        payload.insert = item.defineSchema.insert
      }
      onSelect(payload)
    } else {
      onSelect({name: item, type, insert: true})
    }
  }

  const clickVariable = (variable) => {
    if (variable.defineSchema.nodeType === 'function') {
      clickItem(variable.defineSchema.title, variable.defineSchema.nodeType)
    } else {
      clickItem(variable, 'variable')
    }
  }

  function splitFormula(formula) {
    const dotIndex = formula.indexOf('.');
    const type = formula.substring(0, dotIndex);
    const name = formula.substring(dotIndex + 1);
    return { type, name };
  }

  const mouseOverVariable = (variable) => {
    const subSchema = getVariableByPath(schema ,variable.path)
    setSchemaActive(subSchema)
    if (subSchema.nodeType === 'function') {
      
    } else {
      
    }
  }

  const mouseOverFuntion = (parentType, name, type) => {
    const typeMap = {
      string: 'String',
      number: 'Number',
      time: 'String',
      array: 'Array',
      object: 'Object',
      boolean: 'Boolean'
    }
    setSchemaActive({
      title: name,
      type: type,
      description: createDescription(doc, typeMap[parentType], name)
    })
  }

  const mouseOverExtFunction = (type, name, subSchema) => {
    setSchemaActive({
      title: subSchema.title,
      type: subSchema.nodeType,
      description: createDescription(doc, type || name, name)
    })
  }
      

  React.useEffect(() => {
    setBreadvariable(null)
  }, [ JSON.stringify(varAndFun) ])

  const getCurrentList = async ({schema, breadvariable, varAndFun, limit, querySchema}) => {
    const _currentList = await getVariablesSchemaList(schema, breadvariable ? breadvariable : varAndFun, limit, querySchema)
    setCurrentList(_currentList)
  }

  React.useEffect(() => {
    getCurrentList({schema, breadvariable, varAndFun, limit, querySchema})
  }, [ schema, breadvariable, varAndFun, limit, querySchema])

 

  const funList = getFunList(parentType, varAndFun.functionText)

  const getType = (type, nodeType) => {
    if (nodeType && nodeType.indexOf('Properties') !== -1) {
      return type
    } else {
      return nodeType || type
    }
  }

  return (
    <div className="iot-editor-variable-select">
      {
        hasLoading ? (
          <div className="iot-editor-variable-select-loading">
            <Spin></Spin>
          </div>
        ): (
          <>
            {/* 预期结果 */}
            <div className="expected-line" style={{ height: '34px', lineHeight: '34px' }}>
              {/* <span className="equal-icon">=</span> */}
              <span className="error">{error}</span>
              <span className="expected-type">
                <Tooltip placement="top" title={_t1(typeMap[expected.type]?.title)}>
                  <TypeIcon type={expected.type} />
                </Tooltip>
              </span>
              {
                !isFormula && !isSelectFormula ? (
                  <span title={_t1("插入公式")} className="full-dialog-icon" onClick={onInsertFormula}>
                    <i className="editor-iconfont" dangerouslySetInnerHTML={{__html: '&#xea66;'}} ></i>
                  </span>
                ) : null
              }
              {
                onFull ? (
                  <span title={_t1("全屏")} className="full-dialog-icon" onClick={onFull}>
                    <i className="editor-iconfont" dangerouslySetInnerHTML={{__html: '&#xea11;'}} ></i>
                  </span>
                ) : null
              }
            </div>
            {/* 变量面板 */}
            <div style={{ width: '100%', borderBottom: '1px #E1E1E1 solid'}}></div>
            <div className="iot-editor-select-panel">
              <VariableBreadcrumb parentVariable={varAndFun?.variable} onClick={variable => { setBreadvariable(variable) }}></VariableBreadcrumb>
              {
                currentList.length || funList.length ? (
                  <div className="select-panel-content">
                    <div className="select-panel-list">
                      {
                        currentList.length ? <>
                          <div className="select-panel-title">变量</div>
                          {
                            currentList.map((variable) => {
                              return (
                                <div className="select-panel-item" onClick={() => {clickVariable(variable)}} onMouseOver={() => { mouseOverVariable(variable) }}>
                                  <TypeIcon type={getType(variable.defineSchema.type, variable.defineSchema.nodeType) || 'object'} />
                                  <div className="select-panel-item-title" title={_t1(variable.defineSchema.title || variable.key)} >{_t1(variable.defineSchema.title || variable.key)}</div>
                                </div>
                              )
                            })
                          }
                        </> : null
                      }

                      {
                        funList.length ? <>
                          <div className="select-panel-title">{typeMap[parentType].title}类型函数</div>
                          {
                            funList.map(name => {
                              const typeInfo = typeof typeMap[parentType].Creator.prototype[name] === 'function' ? {title: _r('函数'), type: 'function'} : {title: _r('属性'), type: 'attr'}
                              return (
                                <div className="select-panel-item" onClick={() => {clickItem(name, typeInfo.type)}} onMouseOver={() => { mouseOverFuntion(parentType, name, typeInfo.type) }}>
                                  <TypeIcon type={typeInfo.type} />
                                  {name}
                                </div>
                              )
                            })
                          }
                        </> : null
                      }
                      {
                        (isFormula || isSelectFormula) && functionSchema?.length ? functionSchema.map(schema => {
                          const keys = _.keys(schema.properties).filter(key => varAndFun.wordText ? key.indexOf(_.trim(varAndFun.wordText)) !== -1 : true)
                          return keys?.length ? <>
                            <div className="select-panel-title">{schema.title}</div>
                            {
                              keys.map(key => {
                                return (
                                  <div className="select-panel-item" onClick={() => {clickItem(key, 'wordFunction')}} onMouseOver={() => { mouseOverExtFunction(schema.id, key.split('.').reverse()[0], schema.properties[key]) }}>
                                  <TypeIcon type='function' />
                                  {key}
                                </div>
                                )
                              })
                            }
                          </> : null
                        }) : null
                      }
                      {
                        attrSchema?.length ? attrSchema.map(schema => {
                          const keys = _.keys(schema.properties).filter(key => varAndFun.wordText ? key.indexOf(_.trim(varAndFun.wordText)) !== -1 : true)
                          return keys?.length ? <>
                            <div className="select-panel-title">{schema.title}</div>
                            {
                              keys.map(key => {
                                return (
                                  <div className="select-panel-item" onClick={() => {clickItem(key, 'attr')}} onMouseOver={() => { mouseOverExtFunction(schema.id, key.split('.').reverse()[0], schema.properties[key]) }}>
                                  {/* <TypeIcon type='attr' /> */}
                                  {key}
                                </div>
                                )
                              })
                            }
                          </> : null
                        }) : null
                      }
                    </div>
                    <div className="select-panel-detail">
                      {
                        schemaActive ? (
                          <>
                            <div className="detail-title">
                              <div>{_t1(schemaActive.title)}</div>
                              <div className="detail-type">
                                <TypeIcon type={schemaActive.nodeType || schemaActive.type} />
                                {_t1(typeMap[schemaActive.nodeType || schemaActive.type]?.title)}
                              </div>
                            </div>
                            <div className="detail-description" style={{fontSize: 14}}>{schemaActive.description}</div>
                            {/* {
                              _.keys(schemaActive.properties).length ? (
                                <div className="detail-info">
                                  {
                                    _.keys(schemaActive.properties).map(key => {
                                      return (
                                        <div className="detail-info-item">
                                          <div className="info-item-title">{_t1(schemaActive.properties[key].title || key)}</div>
                                          <TypeIcon type={schemaActive.properties[key].nodeType || schemaActive.properties[key].type} />
                                        </div>
                                      )
                                    })
                                  }
                                </div>
                              ) : null
                            } */}
                          </>
                        ) : null
                      }
                    </div>
                  </div>
                ) : null
              }
              
            </div>
          </>
        )
      }
    </div>
  )
}

export default VariableSelect
