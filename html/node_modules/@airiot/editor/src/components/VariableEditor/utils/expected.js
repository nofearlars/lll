
import _ from 'lodash'

const errorTrans = {
  'Getter must not have any formal parameters': '获取器不能有任何形式的参数',
  'Setter must have exactly one formal parameter': '设置器必须只有一个形式参数',
  'Setter function argument must not be a rest parameter': '设置器函数参数不能是其余参数',
  'Class constructor may not be an async method': '类构造函数不能是异步方法',
  'Class constructor may not be an accessor': '类构造函数不能是访问器',
  'Missing initializer in %0 declaration': '在%0声明中缺少初始化器',
  'Unexpected token =': '意外的符号 =',
  'Duplicate binding %0': '重复绑定 %0',
  'A class may only have one constructor': '一个类只能有一个构造函数',
  'Duplicate __proto__ fields are not allowed in object literals': '在对象字面量中不允许有重复的 __proto__ 字段',
  '%0 loop variable declaration may not have an initializer': '%0循环变量声明可能没有初始化器',
  'Generator declarations are not allowed in legacy contexts': '在遗留上下文中不允许生成器声明',
  'Illegal break statement': '非法的 break 语句',
  'Illegal continue statement': '非法的 continue 语句',
  'Unexpected token': '意外的符号',
  'Illegal \'use strict\' directive in function with non-simple parameter list': '在具有非简单参数列表的函数中非法的 \'use strict\' 指令',
  'Illegal return statement': '非法的 return 语句',
  'Keyword must not contain escaped characters': '关键字不能包含转义字符',
  'Invalid hexadecimal escape sequence': '无效的十六进制转义序列',
  'Invalid left-hand side in assignment': '在赋值中无效的左侧',
  'Invalid left-hand side in for-in': '在for-in中无效的左侧',
  'Invalid left-hand side in for-loop': '在for-loop中无效的左侧',
  'Invalid regular expression': '无效的正则表达式',
  'let is disallowed as a lexically bound name': 'let作为词法绑定名称是不允许的',
  'Unexpected token': '意外的符号',
  'More than one default clause in switch statement': '在switch语句中有多于一个的default子句',
  'Illegal newline after throw': '在throw后面非法的换行符',
  'Unexpected token': '意外的符号',
  'Missing catch or finally after try': '在try后面缺少catch或finally',
  'Rest parameter must be last formal parameter': '其余参数必须是最后的形式参数',
  '%0 \'%1\' has already been declared': '%0 \'%1\' 已经被声明',
  'Classes may not have static property named prototype': '类不能有名为prototype的静态属性',
  'Catch variable may not be eval or arguments in strict mode': '在严格模式下，捕获变量不能是eval或arguments',
  'Delete of an unqualified identifier in strict mode.': '在严格模式下删除一个无资格的标识符',
  'In strict mode code, functions can only be declared at top level or inside a block': '在严格模式代码中，函数只能在顶级或块内部声明',
  'Function name may not be eval or arguments in strict mode': '在严格模式下，函数名不能是eval或arguments',
  'Assignment to eval or arguments is not allowed in strict mode': '在严格模式下，不允许给eval或arguments赋值',
  'Postfix increment/decrement may not have eval or arguments operand in strict mode': '在严格模式下，后缀递增/递减可能没有eval或arguments操作数',
  'Prefix increment/decrement may not have eval or arguments operand in strict mode': '在严格模式下，前缀递增/递减可能没有eval或arguments操作数',
  'Strict mode code may not include a with statement': '严格模式代码不能包含一个with语句',
  'Octal literals are not allowed in strict mode.': '在严格模式下，不允许八进制字面量',
  'Strict mode function may not have duplicate parameter names': '严格模式函数可能没有重复的参数名称',
  'Parameter name eval or arguments is not allowed in strict mode': '在严格模式下，参数名eval或arguments是不允许的',
  'Use of future reserved word in strict mode': '在严格模式下，使用未来保留的单词',
  'Variable name may not be eval or arguments in strict mode': '在严格模式下，变量名可能不是eval或arguments',
  'Octal literals are not allowed in template strings.': '在模板字符串中，不允许八进制字面量',
  'Unexpected end of input': '意外的输入结束',
  'Unexpected identifier': '意外的标识符',
  'Unexpected number': '意外的数字',
  'Unexpected reserved word': '意外的保留字',
  'Unexpected string': '意外的字符串',
  'Unexpected quasi %0': '意外的准 %0',
  'Unexpected token %0': '意外的符号 %0',
  'Unexpected token ILLEGAL': '意外的非法符号',
  'Undefined label \'%0\'': '未定义的标签 \'%0\'',
  'Invalid regular expression: missing /': '无效的正则表达式：缺少 /'
}

function validateJS(code, esprima) {
  try {
    esprima.parseScript(code);
    return null; // 语法校验通过
  } catch (error) {
    return errorTrans[error.description] || error.description
  }
}

const formulaToExpression = (formula) => {
  if (!_.isArray(formula)) {
    return null
  }
  const expression = formula.map(item => {
    if (item.type === 'variable') {
      return `variable('${item.variable.path}')`
    } else {
      return item.text
    }
  }).join('')
  return expression
}

const formulaTest = (formula, isFormula, esprima) => {
  if (isFormula) {
    const expression = formulaToExpression(formula)
    return validateJS(expression, esprima)
  } else {
    if (_.isArray(formula)) {
      const formulaList = formula.filter(item => item.type === 'formula')
      for (let item of formulaList) {
        const expression = formulaToExpression(item.children)
        const error = validateJS(expression, esprima)
        if (error) {
          return error
        }
      }
      return null
    }
    return null
    
  }
}

export { formulaToExpression, formulaTest }
