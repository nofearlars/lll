import _ from 'lodash'

const compiledTemplate = (str, data) => {
  try {
    if (str && data) {
      const _str = str.replace('#$systemVariable', 'systemVariable')
      const _data = JSON.parse(JSON.stringify(data).replace('#$systemVariable', 'systemVariable'))
      const reg = /{{([\s\S]+?)}}/g
      const compiled = _.template(_str, { 'interpolate': reg })
      const result = compiled(_data)
      return result
    } else {
      return ''
    }
  } catch (e) {
    // console.error(e)
    return ''
  }
  
}

const expressionEval = (expressionStr, data) => {
  try {
    const expression = compiledTemplate(expressionStr, data)
    const result = eval(expression)
    let type = typeof result
    if (type === 'object' && result instanceof Array) {
      type = 'array'
    }
    return { error: false, result, type, reality: !!data }
  } catch {
    return { error: true, result: _r('公式错误'), type: 'string', reality: !!data }
  }
}

const elementStringify = (element, data) => {
  if (element.type === 'variable' && element.variable) {
    return `{{${element.variable.path}}}`
  } else if (element.type === 'formula') {
    if (data) {
      const expressionStr = editorValueStringify(element.children)
      const result = expressionEval(expressionStr, data).result
      return _.isString(result) ? result : `${JSON.stringify(result)}`
    } else {
      return `{#${editorValueStringify(element.children)}#}`
    }
  } else {
    return element.text
  }
}

const editorValueStringify = (value, customStringify) => {
  if (_.isArray(value)) {
    return value.map(element => {
      return customStringify ? customStringify(element, elementStringify) : elementStringify(element)
    }).join('')
  } else {
    return ''
  }
}

const editorValueEval = (value, data) => {
  if (_.isArray(value) && value.length) {
    const _value = value.filter(item => item.type || item.text !== '')
    if (_value.length === 1) {
      const element = _value[0]
      if (element.type === 'variable') {
        return _.get(data, element.variable.path)
      } else if (element.type === 'formula'){
        return expressionEval(editorValueStringify(element.children)).result
      } else {
        return element.text
      }
    } else {
      const template = editorValueStringify(value, (element, elementStringify) => {
        if (element.type === 'formula') {
          return elementStringify(element, data)
        } else {
          return elementStringify(element)
        }
      })
      return compiledTemplate(template, data)
    }
  } else {
    return ''
  }
}


const editorValueParse = (str) => {
  return []
}

const getEditorValue = (origin, isStringify, customStringify, isFormula) => {
  if (isStringify) {
    return editorValueStringify(origin)
  } else {
    return {
      origin: _.cloneDeep(origin),
      stringify: isFormula ? `{#${editorValueStringify(origin, customStringify)}#}` : editorValueStringify(origin, customStringify)
    }
  }
}

export { editorValueStringify, editorValueEval, editorValueParse, getEditorValue }
