/**
 * 自动补全
 * https://gist.github.com/mwrouse/05d8c11cd3872c19c684bd1904a2202e
 */
import * as monaco from 'monaco-editor/esm/vs/editor/editor.api';

/**
 * @param {string} thing
 * @param {boolean} isMember
 */
function getType(thing, isMember) {
  isMember =  (isMember === undefined) ? (typeof isMember === "boolean") ? isMember : false : false; // Give isMember a default value of false
  switch ((typeof thing).toLowerCase()) {
    case "object":
      return monaco.languages.CompletionItemKind.Class;
    case "function":
      return (isMember) ? monaco.languages.CompletionItemKind.Method : monaco.languages.CompletionItemKind.Function;
    default:
      return (isMember) ? monaco.languages.CompletionItemKind.Property : monaco.languages.CompletionItemKind.Variable;
  }
}

/**
 * @param {object} definitions
 * @param {object} model:ITextModel
 * @param {object} position: lineNumber: number, column: number}
 * @param {*} token
 */
export function getCompletionItems(definitions, model, position, token) {
  var lastChars = model.getValueInRange({startLineNumber: position.lineNumber, startColumn: 0, endLineNumber: position.lineNumber, endColumn: position.column});
  var words = lastChars.replace("{\t", "").split(/(\s|{|\()/);
  var activeTyping = words[words.length - 1]; // What the user is currently typing (everything after the last space)
  // If the last character typed is a period then we need to look at member objects of the obj object
  var isMember = activeTyping.charAt(activeTyping.length - 1) === ".";
  var result = [];

  // Used for generic handling between member and non-member objects
  var lastToken = definitions;
  var prefix = '';

  if (isMember) {
    // Is a member, get a list of all members, and the prefix
    var parents = activeTyping.substring(0, activeTyping.length - 1).split(".");
    lastToken = definitions[parents[0]];
    prefix = parents[0];

    // Loop through all the parents the current one will have (to generate prefix)
    for (var i = 1; i < parents.length; i++) {
      if (lastToken.hasOwnProperty(parents[i])) {
        prefix += '.' + parents[i];
        lastToken = lastToken[parents[i]];
      } else {
        // Not valid
        return result;
      }
    }

    prefix += '.';
  }
  // Get all the child properties of the last token
  for (var prop in lastToken) {
    // Do not show properites that begin with "__"
    if (lastToken.hasOwnProperty(prop) && !prop.startsWith("__")) {
      // Get the detail type (try-catch) incase object does not have prototype
      var detail = '';
      try {
        detail = lastToken[prop];
        if (typeof detail === 'object') {
          if (typeof detail.type === 'string' || typeof detail.description === 'string') {
            detail = '字段：' + (detail.description || prop);
          } else {
            detail = '表：' + prop;
          }
        } else {
          detail = '未知字段';
        }
      } catch (e) {
        detail = typeof lastToken[prop];
      }
      // Create completion object
      var toPush = {
        label: prefix + prop,
        kind: getType(lastToken[prop], isMember),
        detail: detail,
        insertText: prop,
        insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
      };

      // Change insertText and documentation for functions
      if (toPush.detail.toLowerCase() === 'function') {
        toPush.insertText += "(";
        toPush.documentation = (lastToken[prop].toString()).split("{")[0]; // Show function prototype in the documentation popup
      }

      // Add to final results
      result.push(toPush);
    }
  }
  return result;
}

export function showAutocompletion(obj) {
    // Disable default autocompletion for javascript
    // monaco.languages.typescript.javascriptDefaults.setCompilerOptions({ noLib: true  });
    // Helper function to return the monaco completion item type of a thing
    // Register object that will return autocomplete items
    monaco.languages.registerCompletionItemProvider('cmdb-calc', {
      // Run this function when the period or open parenthesis is typed (and anything after a space)
      triggerCharacters: ['.', '(', '{'],
      // Function to generate autocompletion results
      provideCompletionItems: function(model, position, token) {
        // Split everything the user has typed on the current line up at each space, and only look at the last word
        let items = getCompletionItems(obj, model, position, token);
        return { suggestions: items};
      }
  });
};
