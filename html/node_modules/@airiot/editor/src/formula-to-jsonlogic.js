/*
 * 一个转换器
 */
var esprima_1 = require("esprima");
var SCOPE_UPGRADE_KEYS = [ '+', '-', '*', '/', '%', '>', '<', '==', '===', '>=', '<=', '!=', '!==', '&', '|' ];
/**
 * 作用域提升，比如 { "+": [ { "+": [ 1, 2 ] }, 3 ] } 需要变成：{"+": [1, 2, 3]}
 * 支持 + - * / %
 * @param json
 * @return Object 优化后的对象
 */
var opMerge = function (json) {
    if (!json) {
        return json;
    }
    for (var _i = 0, SCOPE_UPGRADE_KEYS_1 = SCOPE_UPGRADE_KEYS; _i < SCOPE_UPGRADE_KEYS_1.length; _i++) {
        var upgradeKey = SCOPE_UPGRADE_KEYS_1[_i];
        var values = json[upgradeKey] || [];
        for (var index in values) {
            var value = values[index];
            if (value && value[upgradeKey]) {
                json[upgradeKey] = values.slice(0, index).concat(value[upgradeKey], values.slice(index + 1));
            }
        }
    }
    return json;
};
var node2Json = function (node) {
    var _a, _b;
    var result = {};
    switch (node.type) {
        case 'Identifier':
            result = {
                'var': [node.name]
            };
            break;
        case 'Literal':
            result = node.value;
            break;
        case 'MemberExpression':
            let objName = node.object.name
            result = {
                // @ts-ignore
                'var': [(objName == 'data' ? 'var' : objName)  + "." + node.property.name]
            };
            break;
        case 'BinaryExpression':
            var opKey = node.operator;
            result = (_a = {},
                _a[opKey] = [
                    node2Json(node.left),
                    node2Json(node.right)
                ],
                _a);
            result = opMerge(result);
            break;
        case 'CallExpression':
            var args = node.arguments;
            var callee = node.callee;
            var op = callee.name.toLowerCase();
            result = (_b = {},
                // @ts-ignore
                _b[op] = args.map(node2Json),
                _b);
            break;
        case 'ExpressionStatement':
            result = node2Json(node.expression);
            break;
        default:
            console.error('未能处理的逻辑: ', node);
            break;
    }
    return result;
};
var logic2Str = function (logic) {
    if (logic === undefined) {
        return '';
    }
    else if (['number', 'string', 'boolean'].indexOf(typeof logic) > -1) {
        return logic.toString();
    }
    else if (Array.isArray(logic)) {
        return logic.map(logic2Str);
    }
    else {
        var result = '';
        var logicObject = logic;
        for (var op in logicObject) {
            var value = logicObject[op] || '';
            if (op.toUpperCase() === 'VAR') {
                return (value && value[0])?.replace('var.', 'data.');
            }
            var args = [];
            if (Array.isArray(value)) {
                args = value.map(function (v) { return logic2Str(v); });
            }
            else {
                args = [logic2Str(value)];
            }
            if (SCOPE_UPGRADE_KEYS.indexOf(op) > -1) {
                result += args.join(" " + op + " ");
            }
            else {
                result += op.toUpperCase() + "(" + args.join(', ') + ")";
            }
        }
        return result;
    }
};
/**
*
* @param str
* @constructor
*/
// @ts-ignore
var Formula2Jsonlogic = function (str) {
    if (!str) {
        return;
    }
    try {
        var program = esprima_1.parseScript(str);
        return node2Json(program.body[0]);
    }
    catch (e) {
        return e;
    }
};
/**
 * 将LogicJSON
 * @param jsonLogic
 * @constructor
 */
// @ts-ignore
var JsonLogic2Formula = function (logicJSON) {
    if (!logicJSON) {
        return '';
    }
    return logic2Str(logicJSON);
};

export {
    opMerge,
    Formula2Jsonlogic,
    JsonLogic2Formula
}
