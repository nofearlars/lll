import React from 'react'
import _ from 'lodash'
import { FieldArray, objectBuilder, prefixFieldKey } from 'xadmin-form'
import XLSX from 'xlsx'
import { saveAs } from 'file-saver'
import { Button, Input, Collapse, Form, Alert, Radio, Card, Typography, Tooltip, message, Popconfirm } from 'antd'
import { Icon, C } from 'xadmin-ui'
import { app, use } from 'xadmin'
import UploadButton from './UploadButton'

/* see Browser download file example in docs */
function s2ab(s/*:string*/)/*:ArrayBuffer*/ {
  const buf = new ArrayBuffer(s.length)
  const view = new Uint8Array(buf)
  for (let i = 0; i != s.length; ++i) view[i] = s.charCodeAt(i) & 0xFF
  return buf
}

const getColumns = (items, data) => {
  const columns = []
  const parseFields = (ffs, columns, prefix) => {
    if (ffs && ffs.length > 0) {
      ffs.forEach(f => {
        const ff = [...prefix, f]
        if (f.type == 'fieldset' && f.fields) {
          parseFields(f.fields, columns, ff)
          // } else if(f.type == 'array' && f.items) {

        } else {
          if (f.schema.export !== false) {
            columns.push({
              field: f, label: ff.map(f => f.label).join('-'), path: f.name
            })
          }
        }
      })
    } else {
      if (data.label) {
        columns.push({ field: data.field, label: data.field.label, path: data.field.name })
      }
    }
  }
  parseFields(items.fields, columns, [])
  return columns
}

const exportData = (props) => {
  const { input: { value = [] }, field: { items, label, schema } } = props
  const columns = getColumns(items, props)

  const setValue = (field, raw) => {
    if (field.schema.export && field.schema.export.read) {
      return field.schema.export.read(raw)
    }
    if (field.type == 'number' || field.type == 'numselect') {
      return !_.isNil(raw) ? parseFloat(raw) : ''
    } else if (field.type == 'array') {
      try {
        return JSON.stringify(raw)
      } catch (error) {
        return '[]'
      }
    } else if (field.schema?.type == 'object') {
      return JSON.stringify(raw)
    }
    return raw
  }

  // const rows = (value || []).map(v => columns.map(col => setValue(col.field, _.get(v, col.path))))
  let rows;
  if (items.fields && items.fields.length) {
    rows = (value || []).map(v => columns.map(col => setValue(col.field, _.get(v, col.path))))
  } else {
    if (schema) {
      if (schema.type == 'array' && schema.items && schema.items.type == 'string') {
        rows = (value || []).map(v => [v])
      }
    }
  }

  const ws = XLSX.utils.aoa_to_sheet([columns.map(f => f.label), ...rows])
  const wb = XLSX.utils.book_new()
  XLSX.utils.book_append_sheet(wb, ws, label)

  /* generate XLSX file */
  const wbout = XLSX.write(wb, { type: 'binary', bookType: 'xlsx' })
  /* send to client */
  saveAs(new Blob([s2ab(wbout)], { type: 'application/octet-stream' }), `导出-${label}.xlsx`)
}

const ArrayComponent = props => {
  const { dispatch } = use('redux')
  const [showCode, setShowCode] = React.useState(false)
  const [search, setSearch] = React.useState(null)
  const [renderKey, setRenderKey] = React.useState(() => {
    const itemRenders = props.itemRenders
    return !_.isEmpty(itemRenders) ? Object.keys(itemRenders)[0] : null
  })
  const [codeError, setCodeError] = React.useState(null)
  const uploader = React.useRef()
  const [selectRule, setSelectRule] = React.useState('false')

  const { input, field, meta: { touched, error }, fields, itemRenders, itemRender } = props
  const { items, label, searchEnable, pushComponent, exportBtn, uploadBtn } = field
  const vs = _.isArray(input.value) ? input.value : []

  const taggleEditMode = () => setShowCode(!showCode)

  const textAreaOnChange = (json) => {
    try {
      const value = JSON.parse(json)
      if (_.isArray(value)) {
        input.onChange(value)
        setCodeError(null)
      } else {
        setCodeError('JSON必须是数组')
      }
    } catch (error) {
      setCodeError('JSON格式错误')
    }
  }

  const onFileReady = () => {
    const source = uploader.current
    const f = source.files[0]
    const reader = new FileReader()

    reader.onload = (e) => {
      const data = e.target.result
      const wb = XLSX.read(data, { type: 'binary' })

      const wsname = wb.SheetNames[0]
      const ws = wb.Sheets[wsname]
      const jsonData = XLSX.utils.sheet_to_json(ws)

      importData(jsonData)
      source.value = '' //清空上传文件组件的文件，可以再次上传同样的文件
    }
    reader.readAsBinaryString(f)
  }

  const importData = (data) => {
    const { field: { items, label } } = props
    const headers = getColumns(items, props).reduce((prev, col) => {
      prev[col.label] = col
      return prev
    }, {})

    const getValue = (field, raw) => {
      if (field.schema.export && field.schema.export.write) {
        return field.schema.export.write(raw)
      }

      if (field.type == 'number' || field.type == 'numselect') {
        const num = parseFloat(raw)
        return _.isNaN(num) ? null : num
      } else if (field.type == 'array') {
        // try {
        //   return JSON.parse(raw)
        // } catch (error) {
        //   return []
        // }
        if (field.schema.type == 'array' && field.schema.items && field.schema.items.type == 'string') {
          return raw
        } else {
          try {
            return JSON.parse(raw)
          } catch (error) {
            return []
          }
        }
      } else if (field.schema?.type == 'object') {
        try {
          return JSON.parse(raw)
        } catch (error) {
          return {}
        }
      }
      return raw
    }

    const json = data.map(row => {
      let v = {}
      Object.keys(row).forEach(key => {
        if (headers[key] && headers[key].path) {
          const val = getValue(headers[key].field, row[key])
          // if(!_.isNil(val)) {
          //   _.set(v, headers[key].path, val)
          // }
          if (headers[key].field.schema.type == 'array' && headers[key].field.schema.items && headers[key].field.schema.items.type == 'string') {
            if (!_.isNil(val)) {
              v = val
            }
          } else {
            if (!_.isNil(val)) {
              _.set(v, headers[key].path, val)
            }
          }
        }
      })
      return v
    })

    const reduceVS = (data) => {
      if (!data) return {}
      return data.reduce((prev, cur) => {
        if (cur?.id) prev[cur?.id] = cur
        return prev
      }, {})
    }

    try {
      // 导入规则处理
      if (selectRule == 'false') {
        // 跳过
        const newVs = [...vs]
        const objectVs = reduceVS(vs)
        json.forEach(j => {
          if (j?.id || j?.warningname) {
            if (objectVs[j?.id || j?.warningname]) {
              message.warning(`${j?.name || j?.warningname || ''}唯一标识已存在，已跳过`)
            } else {
              newVs.push(j)
            }
          }
        })
        input.onChange(newVs)
        message.success(`${label} 部分数据导入成功。`)
      } else if (selectRule == 'true') {
        // 覆盖更新
        const newVs = Object.values(Object.assign(reduceVS(vs), reduceVS(json)))
        input.onChange(newVs)
        message.success(`${label} 导入成功。`)
      }
    } catch (err) {
      console.log(err)
    }
  }

  const cleanAll = () => input.onChange([])

  let ItemsRender = itemRender
  if (!_.isEmpty(itemRenders) && _.isNil(ItemsRender)) {
    ItemsRender = renderKey ? itemRenders[renderKey] : Object.values(itemRenders)[0]
  }
  if (_.isNil(ItemsRender)) {
    ItemsRender = defaultItemsRender
  }

  const CodeEditor = C('CodeEditor')
  const ExportBtn = exportBtn
  const UploadBtn = uploadBtn

  return (
    <>
      {/* , justifyContent: 'space-between' */}
      <div style={{ display: 'flex', marginBottom: '.5rem' }}>
        <Button.Group size="small" style={{ flex: 1 }}>
          <Tooltip title={_t1('添加')}>
            <Button onClick={() => {
              fields.push(items.type == 'fieldset' ? {} : null)
              setSearch(undefined)
            }}><Icon name="plus" /></Button></Tooltip>
          <Tooltip title={_t1('代码编辑')}>
            <Button onClick={() => taggleEditMode()}><Icon name={showCode ? 'eye' : 'form'} /></Button>
          </Tooltip>
          <Tooltip title={_t1('清空')}>
            <Popconfirm title={_t1('您确定要清空全部内容吗？')} onConfirm={cleanAll}>
              <Button><Icon name="clear" /></Button>
            </Popconfirm>
          </Tooltip>
          {/* 自定义导出导入 */}
          {exportBtn ? <ExportBtn {...props} /> : <Tooltip title={_t1('导出')}> <Button onClick={() => exportData(props)}><Icon name="export" /></Button> </Tooltip>}
          {/* <Tooltip title={_t1('导入')}>
            <Button onClick={() => { uploader.current.click() }}><Icon name="import" /></Button>
          </Tooltip> */}
          {uploadBtn ? <UploadBtn uploader={uploader.current} field={props.field} {...props} /> : <UploadButton
            field={props.field}
            uploader={uploader.current}
            selectRule={selectRule}
            setSelectRule={setSelectRule}
          />}
          {pushComponent || null}
        </Button.Group>

        <div style={{ display: 'flex' }}>
          {!_.isEmpty(itemRenders) ? (
            <Radio.Group value={renderKey} size="small" style={{ marginRight: '.5rem' }} onChange={e => setRenderKey(e.target.value)}>
              {
                Object.keys(itemRenders).map(key => <Radio.Button value={key}>{key}</Radio.Button>)
              }
            </Radio.Group>
          ) : null}
          {searchEnable ? <Form layout="inline" onKeyDown={e => { if (event.keyCode == 13) { return false } }}>
            <Input.Search placeholder={_t1('查询')} allowClear onChange={(e) => setSearch(e.target.value)} value={search} size="small" />
          </Form> : null}
        </div>
      </div>
      <input type="file" ref={uploader} style={{ display: 'none' }} name="file" onChange={onFileReady} />
      {
        showCode ? (
          <div>{
            CodeEditor ?
              <C is="CodeEditor"
                language={"json"}
                value={JSON.stringify(vs, null, 2)}
                options={{ minimap: { enabled: false } }}
                width="100%"
                height={500}
                onChange={textAreaOnChange}
              /> : <Input.TextArea autoSize={{ minRows: 4, maxRows: 30 }} onChange={e => textAreaOnChange(e.target.value)}
                defaultValue={JSON.stringify(vs, null, 2)} />}
          </div>
        ) : <ItemsRender {...props} search={search} withAdd={false} />
      }
      {codeError ? <Alert style={{ marginTop: '.5rem' }} message={codeError} type="error" showIcon /> : null}
    </>
  )

}

const defaultItemsRender = ({ input, fields, search, meta: { touched, error }, field, fieldsBuilder }) => {
  const { items, label } = field
  const vs = _.isArray(input.value) ? input.value : []

  return fields.length ? (items.type == 'fieldset' ? (
    <Collapse bordered={true}>
      {fields.map((name, index) => {
        const value = vs[index] || {}
        const err = error && error[index]
        const objectName = value.name || value.title || (index + 1).toString()
        const removeBtn = (<Button size="small" onClick={(e) => { fields.remove(index); e.stopPropagation() }} style={{ float: 'right', marginRight: 15 }}><Icon name="minus" /></Button>)
        const itemLable = (<Typography.Text type={err ? 'danger' : undefined}>{label + ' ' + objectName}{removeBtn}</Typography.Text>)
        const fieldsComponent = fieldsBuilder(name, index, removeBtn, itemLable)
        return (<Collapse.Panel header={itemLable} eventKey={index} key={`items${index}`}>
          {fieldsComponent}
        </Collapse.Panel>)
      })}
    </Collapse>
  ) : (
    <Card bodyStyle={{ padding: '15px 0 0' }}>
      {fields.map((name, index) => {
        const value = vs[index] || {}
        const objectName = value.name || value.title || (index + 1).toString()
        const removeBtn = (<Button size="small" onClick={() => fields.remove(index)} style={{ float: 'left', marginRight: 15 }}><Icon name="delete" /></Button>)
        const itemLable = (<span>{removeBtn}{label + ' ' + objectName}</span>)
        const fieldsComponent = fieldsBuilder(name, index, removeBtn, itemLable)
        return fieldsComponent
      })}
    </Card>
  )) : null
}

export default ({ input, label, meta, field, option }) => {
  let renderItems = field.itemsRender
  if (typeof renderItems === 'string') {
    renderItems = app.load_dict('array_render')[renderItems]
  }
  // 多个render自由选择
  let itemRenders = null
  if (!_.isEmpty(field.itemsRenders)) {
    itemRenders = Object.keys(field.itemsRenders).reduce((prev, key) => {
      let renderItems = field.itemsRenders[key]
      if (typeof renderItems === 'string') {
        renderItems = app.load_dict('array_render')[renderItems]
      }
      prev[key] = renderItems
      return prev
    }, {})
  }

  const { items, exports, toLead } = field
  const fieldsBuilder = (name, index, removeBtn, itemLable) => {
    const itemFields = items.fields ?
      items.fields.map(f => prefixFieldKey(f, name + '.')) :
      [{ ...items, key: name, name: name, label: itemLable }]
    return objectBuilder(itemFields, items.render, option)
  }
  return (
    <FieldArray
      name={field.name}
      label={label}
      input={input}
      meta={meta}
      component={ArrayComponent}
      itemRender={renderItems}
      itemRenders={itemRenders} field={field} fieldsBuilder={fieldsBuilder} />
  )
}
