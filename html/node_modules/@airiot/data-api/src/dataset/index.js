import React from 'react'
import { api, use } from 'xadmin'
import { C } from 'xadmin-ui'
import _ from 'lodash'
import { Button, Select } from 'antd'
import CodeEditor from './CodeEditor'
import useField from '../useField'
import { convertSchema } from '../models'

const useDataSource = (props) => {
  const { op, params, predata, interval, scriptConfig = {}, testConfig = {} } = props
  const url = op?.key ? `ds/p/${op.key}` : null
  const { script } = scriptConfig
  const { submit } = testConfig
  const [dataset, setDataset] = React.useState([])
  const [loading, setloading] = React.useState(false)

  const { t: _t1 } = useI18n()

  const editMode = use('dashboard.mode')

  const queryCallback = React.useRef()
  const submitRef = React.useRef()

  const filterResult = (json) => {
    let _json = json
    let dimensions, source = []

    if (_.isPlainObject(_json)) {
      _json = [_json]
    } else if (_.isArray(_json)) {
      // nothing
    } else {
      _json = [{ result: _json }]
    }

    _json.map((item) => {
      const keys = _.keys(item)
      dimensions = _.union(dimensions, keys)
    })
    _json.map((item) => {
      const values = []
      dimensions.map(key => {
        values.push(item[key])
      })
      source.push(values)
    })

    return { dimensions, source }
  }

  const filterData = (data) => {
    if (predata) {
      data = filterResult(data)
    }
    const e = eval(script)
    if (e.transformData) {
      data = e.transformData(data)
    }
    return data
  }

  const fetchData = () => {
    let path = url
    if (path) {
      setloading(true)
      api({ name: path }).fetch('', {
        method: 'POST',
        body: JSON.stringify(params?.value || {})
      }).then(({ json }) => {
        const data = filterData(json)
        setloading(false)
        setDataset(data)
      }).catch(err => setloading(false))
    }
  }

  queryCallback.current = fetchData

  React.useEffect(() => {
    if (editMode && submit && submitRef.current != submit) {
      fetchData()
      submitRef.current = submit
    }
  }, [submit])

  React.useEffect(() => {
    if (!editMode) {
      fetchData()
    }
  }, [JSON.stringify(op, params, predata, interval)])

  React.useEffect(() => {
    const tick = () => {
      queryCallback.current()
    }
    if (interval) {
      let id = setInterval(tick, interval * 1000)
      return () => clearInterval(id)
    }
  }, [interval])

  return { dataset, loading }
}

const Submit = ({ input: { onChange } }) => {
  const id = Math.random().toString(24)
  const { config = {} } = use('form', state => ({ config: state.values }))
  return <Button disabled={_.isEmpty(config.op) || config.interval} onClick={() => { onChange(id) }} size="small">{_t1('发送')}</Button>
}

const SelectType = ({ input }) => {

  const [list, setList] = React.useState([])

  const fetchData = () => {
    api({ name: '/ds/group' }).query(
      {},
      {}
    ).then(({ items }) => {
      setList(items)
    })
  }

  React.useEffect(() => {
    fetchData()
  }, [])

  return <Select
    value={input?.value}
    onChange={input.onChange}
    allowClear
  >
    {
      list.map(item => {
        return (
          <Select.Option value={item.id}>
            {item.name}
          </Select.Option>
        )
      })
    }
  </Select>
}

const SelectName = ({ input }) => {

  const ds = useField('ds')

  const [list, setList] = React.useState([])

  const fetchData = () => {
    api({ name: '/ds/interface' }).query(
      {},
      { where: { dataGroup: ds } }
    ).then(({ items }) => {
      setList(items)
    })
  }

  React.useEffect(() => {
    if (ds) {
      fetchData(ds)
    }
  }, [ds])

  const onChange = (key) => {
    const item = list.find(i => i.key === key)
    input.onChange({
      id: item.id,
      key: item.key
    })
  }

  return <Select
    value={input?.value?.key}
    onChange={onChange}
    allowClear
  >
    {
      list.map(item => {
        return (
          <Select.Option value={item.key}>
            {item.name}
          </Select.Option>
        )
      })
    }
  </Select>
}

const getInitVal = (variableSchema) => {
  if (variableSchema) {
    const result = {}
    variableSchema.forEach((item) => {
      result[item.paramKey] = item.defaultValue
    })
    return result
  }
  return null
}

const ParamsForm = props => {

  const { input, field } = props
  const [schema, setSchema] = React.useState(null)
  const [initialValues, setInitialValues] = React.useState(input.value || {})

  const op = useField('op')

  React.useEffect(() => {
    if (op?.id) {
      api({ name: 'ds/interface/' }).fetch(op.id).then(({ json }) => {
        const _schema = convertSchema(json.variableSchema)
        const initial = getInitVal(json.variableSchema)
        if (!input.value && initial) {
          input.onChange(initial)
          setInitialValues({ value: initial })
        } else {
          setInitialValues(input.value || {})
        }
        setSchema({
          type: 'object',
          properties: {
            value: _schema
          }
        })
      })
    }
  }, [op?.id])

  const onChange = values => {
    input.onChange(values)
  }

  return React.useMemo(() => {
    return schema ? <C is="Dashboard.PropForm"
      formKey={`model.${op?.id}`}
      schema={schema}
      initialValues={initialValues}
      group={props => <div className="datasourceParamsForm"><C is='Dashboard.DataGroup' {...props} /></div>}
      bindVar={true}
      component={({ children }) => children}
      onSubmit={onChange}
      onChange={onChange} /> : null
  }, [op?.id, schema, initialValues])

}

const paramSchema = {
  type: 'object',
  properties: {
    ds: {
      title: _r('分组'),
      type: 'string',
      field: {
        component: SelectType
      }
    },
    op: {
      title: _r('接口'),
      type: 'object',
      field: {
        component: SelectName
      }
    },
    params: {
      title: _r('参数'),
      type: 'object',
      field: {
        component: ParamsForm,
      },
      properties: {}
    },
    predata: {
      title: _r('预处理数据'),
      type: 'boolean',
      description: _r('只有接口返回数据为数组格式时，支持预处理数据，否则依然返回原数据')
    },
    interval: {
      title: _r('轮询时间'),
      type: 'number',
      description: _r('数据更新间隔时间，不填写数据不更新，单位（秒）'),
      field: {
        suffix: 's'
      },
      minimum: 0
    },
    scriptConfig: {
      title: _r('脚本'),
      type: 'object',
      fieldType: 'fieldset_card',
      properties: {
        script: {
          type: 'string',
          title: _r('处理脚本'),
          unbind: true,
          field: {
            component: CodeEditor
          }
        }
      }
    },
    testConfig: {
      title: _r('测试'),
      type: 'object',
      fieldType: 'fieldset_card',
      properties: {
        submit: {
          type: 'string',
          title: _r('提交请求'),
          unbind: true,
          field: {
            component: Submit
          }
        }
      }
    }
  }
}

const initParam = {
  config: {
    predata: true
  },
  scriptConfig: {
    script: `({
/**
  * 转换数据方法
  * dimensions: 维度
  * source: 数据
  **/
transformData: function (dataset) {
  // 如果开启【预处理数据】，将会默认生成{dimensions, source}两个对象，前提是返回的数据需要是数组
  var {dimensions, source} = dataset
  // 在此处添加你的处理方法 

  return dataset
}
})`
  }
}

export default {
  api: {
    title: _r('数据接口'),
    useUpdate: useDataSource,
    paramSchema,
    icon: require('./数据接口.svg'),
    initParam
  }
}