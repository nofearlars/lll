import '../charts/liquidFill/src/liquidFill';
import React from 'react'
import { app, use } from 'xadmin'
import { lazy } from 'xadmin-ui'
import { colorDeal } from './colorDeal';
import _ from 'lodash';
import html2canvas from 'html2canvas'
import jsPDF from 'jspdf'
import { message } from 'antd'
// import { StyleContext } from '../Dashboard/container/context'

const Chart = lazy(() => import('./Chart'))

// 递归，字符串转函数
const StrToFunction = obj => {
  let result = _.cloneDeep(obj)
  for (let key in result) {
    if (_.isString(result[key]) && result[key].indexOf(' => ') > -1) {
      result[key] = eval(result[key])
    } else if (_.isObject(result[key])) {
      result[key] = StrToFunction(result[key])
    }
  }
  return result
}

const onExportPdf = (domID, name) => {
  const messageKey = Math.random()
  message.loading({ content: _t1('PDF导出中...'), key: messageKey, duration: 0, style: { marginTop: 40 } })
  setTimeout(() => {
    const dom = document.querySelector(`#${domID}`)
    html2canvas(dom).then(canvas => {
      const contentWidth = canvas.width;
      const contentHeight = canvas.height;
      const pW = contentWidth > 500 ? contentWidth : 500
      const pH = contentHeight > 500 ? contentHeight : 500
      const pageData = canvas.toDataURL("image/jpeg", 1.0);
      const pdf = new jsPDF("", "pt", [pW, pH]);
      const width = pdf.internal.pageSize.width;
      const height = pdf.internal.pageSize.height;
      const w = contentWidth > width - 20 ? width - 20 : contentWidth
      const h = contentHeight > height - 20 ? height - 20 : contentHeight
      pdf.setFontSize(10)
      pdf.addImage(pageData, "jpeg", 10, 10, w, h);
      // 导出pdf文件命名
      pdf.save(`${name || _t1('图表')}.pdf`)
      message.success({ content: _t1('导出PDF成功'), key: messageKey, duration: 2, style: { marginTop: 40 } })
    }).catch(() => message.error({ content: _t1('导出PDF失败'), key: messageKey, duration: 2, style: { marginTop: 40 } }))
  }, 1000)
}

const useChart = props => {
  const { option, chartCode, chartData, __style__, seriesOption, cellKey, __name__, dashboardMode } = props

  const { useApplyValue, useStyleValue } = use('dashboard.style')
  const setFns = use('cell.functions.set', cellKey)
  const domID = dashboardMode ? props.domID : props.domID + '_style'
  const { type } = use('cell.structure.value', cellKey)
  const title = app.get('dashboardWidgets')?.[type]?.title
  const { t: _t1 } = useI18n()

  // const ctxStyle = React.useContext(StyleContext)

  React.useEffect(() => {
    setFns({
      exportPdf: {
        fun: () => onExportPdf(domID, __name__ || title),
        description: _t1('导出PDF')
      }
    })
  }, [domID, __name__])

  let currentStyle = null

  if (__style__) {
    // 图表配置主题
    currentStyle = __style__
  // } else if (ctxStyle) {
  //   // 上下文有主题
  //   currentStyle = ctxStyle
  } else {
    // 全局的主题
    currentStyle = apply
  }

  const apply = useApplyValue()
  const theme = useStyleValue(`${currentStyle}.chart`)

  let newOption = option || { series: [seriesOption] }

  if (chartData && !_.isEmpty(chartData)) {
    let dataset = chartData
    newOption = {
      ...newOption,
      dataset
    }
    
    const d = chartData?.dimensions
    if (d && d[0] && d[0].type == 'time') {
      if (newOption.xAxis) newOption = _.merge(newOption, { xAxis: { type: 'time' } })
      newOption.series = newOption.series.slice(0, d.length - 1).map((s, i) => {
        return { ...s, encode: { x: 0, y: i + 1 } }
      })
    }
  }

  return <Chart
    theme={theme}
    option={colorDeal(StrToFunction(newOption || option))}
    chartCode={chartCode}
  />
}

export default useChart
