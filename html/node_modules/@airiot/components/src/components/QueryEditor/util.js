import _ from 'lodash'
import METHODS from './Methods'

// 将schema.properties转换成数组形式
const convertProps = (properties, form) => {
  let ops = []
  let list = form && !(form.length == 1 && form[0] == '*') ? (form.includes('*') ? _.uniq([...(form.filter(item => item !== '*').map(item => item.key ?? item) || []), ..._.keys(properties)]) : form) : _.keys(properties)  // 和表单显示顺序统一
  const parseProps = (propertKeys, properties, prefix) => propertKeys.map(item => {
    const prev = properties[item] || {}
    if (prev.userType || prev.fieldType == 'user') {
      prev.relateTo = 'User'
    }
    if (prev.relateTo || prev.relate) {
      prev.properties = {}
    }
    if (prev.properties && !_.isEmpty(prev.properties)) {
      prev.key = item
      parseProps(Object.keys(prev.properties), prev.properties, prev)
    } else {
      const title = prev.title ? prefix && prefix.title ? prefix.title + '-' + prev.title : prev.title : null
      // 过滤无名称属性
      title && ops.push({
        ...prev,
        title,
        key: prefix && prefix.key ? prefix.key + '.' + item : item,
      })
    }
  })
  parseProps(list, properties)
  return ops
}

const getMethods = (schema, fieldKey) => {
  const filters = schema.filters ? _.map(schema.filters, val => val)?.reduce((a, b) => a.concat(b)) : []
  const filterSchema = filters.find(v => v.key == fieldKey && v.component)
  const f = fieldKey.replace('.', '.properties.')
  const fieldSchema = _.omit(_.get(schema.properties, f), 'filterByRes') || {}
  const properties = convertProps(schema.properties)
  const ops = properties.filter(item => item.key != 'model' && item.key != 'dashboard')
  const prop = _.find(ops, v => (v.key || v.id) == fieldKey)
  let methods
  if (prop) {
    if (filterSchema) {
      methods = METHODS['relate']
    } else if (fieldSchema.selectType == 'multiple' || ['attachments', 'attachment', 'map', 'parentnode'].indexOf(fieldSchema.fieldType) > -1) { // 定位、附件、附件组等特殊类型
      methods = METHODS['other']
    } else if ((prop.type == 'object' && fieldSchema.fieldType) || fieldSchema.relateTo) {
      methods = METHODS['relateTo']
    } else if ((prop.type == 'array' && (fieldSchema.fieldType || fieldSchema.component)) || fieldSchema.relate) {
      methods = METHODS['relate']
    } else if (fieldSchema.fieldType === 'area') { // 区域 和单选选择器
      methods = METHODS['enum'].filter(m => m?.type != 'multipleSelect')
    } else if ((prop.enum || prop.enum1) && prop.type == 'string') { // 区域 和单选选择器
      methods = METHODS['enum']
    }
    //  else if ((prop.enum || prop.enum1) && prop.type == 'array') { // 多选选择器
    //   methods = METHODS['enums']
    // } 
    else if (fieldSchema.fieldType === 'textEditor') { // 富文本
      methods = METHODS['string'].filter(m => ['contains', 'notContains', 'isNull', 'notNull'].indexOf(m.key) > -1)
    } else {
      const format = ['date', 'datetime', 'date-time', 'time']
      if (format.includes(prop.format) || prop.timeFormat || prop.fieldType == 'datePicker' || prop.fieldType == 'timePicker') {
        methods = METHODS['date']
      } else {
        methods = METHODS[prop.type] || METHODS['other']
      }
    }
    return fieldSchema.filterMethodFn ? fieldSchema.filterMethodFn(methods) : methods
  } else {
    return []
  }
}

const formatFilter = (item, viewSchema, prefix='') => {
  const dateRegex = /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/
  const dateTimeRegex = /^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}$/
  const timeRegex = /^[0-9]{2}:[0-9]{2}:[0-9]{2}$/
  const field = viewSchema?.properties?.[item.field] || {}
  const format = ['date', 'datetime', 'date-time', 'time']
  const isDateAndTime = field.fieldType == 'datePicker' || format.includes(field.format)
  const isDate = field.format == 'date' || field.formatType == 'date'
  let value = _.isPlainObject(item.value) && _.isEmpty(item.value) ? null : _.isPlainObject(item.value) ? _.omit(item.value, ['icon', 'child']) : item.value
  if (_.isString(item.value) && item.method == 'eq') {
    // 时间等于某个时间时后台无法查询 处理为大于等于 小于该值+1秒 (日期不用)
    if (isDate || (!viewSchema && dateRegex.test(item.value))) {
      return { [`${prefix}$gte`]: item.value, [`${prefix}$lte`]: item.value }
    } else if (isDateAndTime || (!viewSchema && dateTimeRegex.test(item.value))) {
      return { [`${prefix}$gte`]: item.value, [`${prefix}$lt`]: moment(new Date(item.value).getTime() + 1000).format('YYYY-MM-DD HH:mm:ss') }
    } else if (field.timeFormat || (!viewSchema && timeRegex.test(item.value))) {
      return { [`${prefix}$gte`]: item.value, [`${prefix}$lt`]: moment(new Date('1970-01-01 ' + item.value).getTime() + 1000).format('HH:mm:ss') }
    } else {
      return item.value
    }
  }   
  if (item.method == 'ne' && (value?.['$regex'] || value?.like)) {
    return { [`${prefix}$not`]: { [`${prefix}$regex`]: value?.['$regex'] || value?.like } }
  }
  if (item.method == 'eq' && (value?.['$regex'] || value?.like)) {
    return { [`${prefix}$regex`]: value?.['$regex'] || value?.like }
  }
  if (item.method == 'ne' || item.method == 'gt' || item.method == 'lt' || item.method == 'gte' || item.method == 'lte') {
    return { [prefix + '$' + item.method]: value }
  }
  if (item.method == 'isNull') {
    return null
  }
  if (item.method == 'notNull') {
    return { [`${prefix}$ne`]: null }
  }
  if (item.method == 'contains') {
    return { [`${prefix}$regex`]: value }
  }
  if (item.method == 'notContains') {
    return { [`${prefix}$not`]: { [`${prefix}$regex`]: value } }
  }
  if (item.method == 'startsWith') {
    return { [`${prefix}$regex`]: '^' + (value || '') }
  }
  if (item.method == 'endsWith') {
    return { [`${prefix}$regex`]: (value || '') + '$' }
  }
  if (item.method == 'nin') {
    const v = value?.in || value?.['$in'] || value
    return _.isArray(v) ? { [`${prefix}$nin`]: v?.map(item => item?.id || item) } : { [`${prefix}$ne`]: v }
  }
  if (item.method == 'in') {
    const v = value?.in || value?.['$in'] || value
    return _.isArray(v) ? { [`${prefix}$in`]: v?.map(item => item?.id || item) } : v
  }
  if (item.method == 'like') {
    return { [`${prefix}$regex`]: value }
  }
  if (item.method == 'notLike') {
    return { [`${prefix}$not`]: { [`${prefix}$regex`]: value }}
  }
  if (item.method == 'range') {
    return { [`${prefix}$gte`]: value.gte, [`${prefix}$lte`]: value.lte }
  }
  if (item.method == 'notRange') {
    return {[`${prefix}$not`]: { [`${prefix}$gte`]: value.gte, [`${prefix}$lte`]: value.lte }}
  }
  return value
}

const formatFilters = (array, schema, prefix='') => {
  let result = {}
  if (array && array.length > 0) {
    array.forEach(item => {
      result[item.field == 'uid' ? 'id' : item.field] = formatFilter(item, schema, prefix)
    })
  }
  return result
}

const convertQueryFilter = (v, schema, prefix='') => {
  if (!schema) return v
  const baseProperties = schema?.properties
  const ws = Object.keys(v)
    .map(item => {
      let k = item
      if (k.indexOf('.') >= 0) { k = k.replace('.', '.properties.') }
      const p = _.get(baseProperties, k)
      const type = p && p.type
      const fv = v[item]
      if (type == 'array' && _.isArray(fv)) {
        return { [item + 'Id']: fv.map(j => j.id) }
      } else if (type == 'object') { 
        // fv为null 或 { $not: null } 是为空、不为空过滤 字段后面不拼Id
        if (_.isNull(fv)) {
          return { [item]: null }
        } else if (_.has(fv, `${prefix}$ne`) && _.isNull(fv?.[`${prefix}$ne`])) {
          return { [item]: { [`${prefix}$ne`]: null } }
        } else {
          return { [item + 'Id']: fv?.id || fv }
        }
      } else {
        return _.isArray(fv) ? { [item + 'Id']: { in: fv.map(j => j.id) } } : { [item]: fv }
      }
    })
    .reduce((p, c) => ({ ...p, ...c }), {})
  return ws
}

const getQueryFilter = (filters, schema, prefix='') => {
  if (filters && filters.length > 0) {
    const filter = _.compact(filters.map(f => convertQueryFilter(formatFilters(f, schema, prefix), schema, prefix)))
    return _.isEmpty(filter) ? null : filter.length == 1 ? filter[0] : { [`${prefix}$or`]: filter }
  }
}

const getOtherCondition = (otherCondition) => {
  const getConditon = ({field, method, value}) => {
    if (method === 'range') {
      return `\"${field}\" >= ${value?.gte} and \"${field}\" <= ${value?.lte}`
    } else if (method === 'notRange') {
      return `\"${field}\" < ${value?.gte} or \"${field}\" > ${value?.lte}`
    } else {
      const opt = {
        'eq': '=',
        'ne': '!=',
        'gt': '>',
        'lt': '<',
        'gte': '>=',
        'lte': '<=',
      }
      return `\"${field}\" ${opt[method]} ${value}`
    }
  }
  return otherCondition?.length  ? [`${otherCondition.map(arr => 
    `(${arr.map(item => `(${getConditon(item)})`).join(' AND ')})`
  ).join(' OR ')}`] : null
}



export { convertProps, getMethods, formatFilters, getQueryFilter, convertQueryFilter, getOtherCondition }