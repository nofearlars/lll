import React, { useState, useEffect, useCallback } from 'react'
import { app, use } from 'xadmin'
import { Icon, C } from 'xadmin-ui'
import { Button, Select, Divider } from 'antd'
import { NullInput, TextInput, VariateRangeTimeInput } from './Methods'
import { convertProps, getMethods } from './util'
import { Model } from 'xadmin-model'

const { Option } = Select

const convert = (schema, options) => {
  const opts = options || {}
  return app.load_list('filter_converter').reduce((prve, converter) => {
    return converter(prve, schema, opts)
  }, {})
}

const convert1 = (schema, options) => {
  const opts = options || {}
  if (opts.path === undefined) {
    opts.path = []
  }
  if (opts.lookup === undefined) {
    opts.lookup = {}
  }
  return app.get('schema_converter').reduce((prve, converter) => {
    return converter(prve, schema, opts)
  }, opts.global && opts.global?.formDefaults ? _.cloneDeep(opts.global.formDefaults) : {})
}

const BindDataWrap = (props) => {

  const { children, bind, DataWrap } = props

  return (
    bind ? (
      DataWrap ? 
      <DataWrap {...props} /> :
      <C is='Dashboard.DataWrap' {...props} />
    ) : children
  )
}

const QueryItemFrom = ({ value, schema, fieldKey, onChange, unbind, timeRangeQuery, DataWrap }) => {

  const { t:_t1 } = useI18n()

  const [methods, setMethods] = useState()
  const [isTime, setIsTime] = useState()
  const [fieldCovert, setFieldCovert] = useState({ schema: schema.properties[fieldKey] || {} })
  const filters = schema.filters ? _.map(schema.filters, val => val)?.reduce((a, b) => a.concat(b)) : []
  const filterSchema = filters.find(v => v.key == fieldKey && v.component)
  const f = fieldKey.replace('.', '.properties.')
  const fieldSchema = _.omit(_.get(schema.properties, f), 'filterByRes') || {}
  const selectMethod = value?.method

  React.useEffect(() => {
    const ms = getMethods(schema, fieldKey)
    setMethods(ms)
    if (['date', 'datetime', 'date-time'].includes(schema.properties[fieldKey]?.format) || schema.properties[fieldKey]?.fieldType == 'datePicker') setIsTime(true)
  }, [schema, fieldKey])

  const onMethodChange = key => {
    onChange({ ..._.omit(value, 'timeRange'), method: key, value: null })
  }

  const onValueChange = v => {
    onChange({ ...value, value: v?.target ? v.target.value : v })
  }
  const onTimeRangeChange = (timeRange, v) => {
    onChange({ ...value, timeRange, value: v })
  }

  const getConvertCom = (fSchema, method) => {
    if (!fSchema.fieldType && !fSchema.relateTo && !fSchema.relate && !fSchema.enum && !fSchema.enum1) return
    let convertSchema
    if (method?.type == 'multipleSelect') {
      convertSchema = convert1({ items: { type: fSchema.type, properties: {}, relateTo: fSchema.relateTo }, ...fSchema, selectType: 'multiple', type: 'array' })
      if (convertSchema.type == 'array') convertSchema = convert(fSchema)
    } else {
      convertSchema = convert(fSchema)
    }
    setFieldCovert({ ...fSchema, ...convertSchema })
    const type = convertSchema.type
    const formFields = app.get('form_fields')
    return formFields[type]?.component
  }

  const ValueComponent = React.useMemo(() => {
    if (!methods) return NullInput
    const method = _.find(methods, m => m.key == selectMethod) || (methods && methods[0])
    if (fieldSchema?.selectFace) fieldSchema.selectFace = 'select'
    const fSchema = { ...filterSchema, ...fieldSchema }
    setFieldCovert({ schema: fSchema })
    if (method?.key == 'isNull' || method?.key == 'notNull') {
      return method?.component
    }
    if (fSchema.fieldType && (fSchema.enum || fSchema.enum1) || fSchema.relateTo || fSchema.fieldType === 'area') {
      return fSchema.component || getConvertCom(fSchema, method) || TextInput
    }
    return fSchema.component || method?.component || getConvertCom(fSchema, method) || TextInput
  }, [JSON.stringify(methods), selectMethod])

  const [rangeType, setRangeType] = useState(value?.timeRange?.rangeType)

  return (
    <>
      <div style={{ width: '100%', display: 'flex', flexDirection: 'row', marginBottom: '0.5rem' }}>
        <Select
          value={selectMethod}
          placeholder={_t1("请选择")}
          style={{ marginRight: '0.5rem', width: 100, height: 'max-content' }}
          onChange={onMethodChange}
          allowClear
        >
          {(methods || []).map(m => {
            return <Option value={m.key}>{_t1(m.name)}</Option>
          })}
        </Select>
        <div style={{ flexGrow: 1 }}>
          {
            selectMethod ?
              (selectMethod == 'range' || selectMethod == 'notRange') && timeRangeQuery && isTime ?
                <Select defaultValue='fixed' value={rangeType} onChange={v => { setRangeType(v); onChange({ ...value, timeRange: { rangeType: v } }) }}>
                  <Select.Option value='fixed'>{_t1('固定范围')}</Select.Option>
                  <Select.Option value='dynamic'>{_t1('变化范围')}</Select.Option>
                </Select> :
                <BindDataWrap input={{ value: value?.value, onChange: onValueChange }} field={{ ...fieldSchema, unbind: unbind }} bind={!unbind} DataWrap={DataWrap}>
                  <ValueComponent {...fieldSchema} input={{ value: value?.value, onChange: onValueChange }} field={fieldCovert} label={_t1(fieldSchema.title)} meta={{}}/>
                </BindDataWrap>
              : null
          }
        </div>
      </div>
      {
        (selectMethod == 'range' || selectMethod == 'notRange') && timeRangeQuery && isTime &&
        (rangeType == 'dynamic' ? <VariateRangeTimeInput {...fieldSchema} input={{ value: value?.timeRange, onChange: onTimeRangeChange }} field={fieldCovert} label={fieldSchema.title}></VariateRangeTimeInput> :
          <div style={{ marginBottom: '0.5rem' }}>
            <BindDataWrap input={{ value: value?.value, onChange: onValueChange }} field={{ ...fieldSchema, unbind: unbind }} bind={!unbind} DataWrap={DataWrap}>
              <ValueComponent {...fieldSchema} input={{ value: value?.value, onChange: onValueChange }} field={fieldCovert} label={_t1(fieldSchema.title)} meta={{}}/>
            </BindDataWrap>
          </div>)
      }
    </>
  )
}

const getType = (item) => {
  // 工作表显示字段类型，不显示数据类型
  if (item.config) return item.config
  const typeList = { string: _r('字符串'), number: _r('数字'), integer: _r('整数'), boolean: _r('布尔'), object: _r('对象'), array: _r('数组') }
  return _t1(typeList[item.type]) || _t1('字符串')
}

const QueryFieldSelect = ({ schema, value, onChange }) => {

  const { t:_t1 } = useI18n()

  const properties = convertProps(schema.properties, schema.form)
  const ops = properties.filter(item => item.key != 'model' && item.key != 'dashboard' && item.fieldType !== 'editableTable')

  return (
    <Select
      showSearch
      value={value}
      style={{ marginRight: '0.5rem', flexGrow: 1 }}
      placeholder={_t1("选择过滤字段")}
      optionFilterProp="children"
      onChange={onChange}
    >
      {ops.map(item => {
        const key = item.key || item.id
        const title = item.title || item.name
        if (!key || !title) return null
        return <Option value={key} key={key}><span style={{ color: '#999' }}>[{_t1(getType(item))}]</span> {title}</Option>
      })}
    </Select>
  )
}

const QueryItem = (props) => {
  const { value, schema, onChange, onDelete, selectHide } = props

  return (
    <>
      {selectHide ? null : <div style={{ width: '100%', display: 'flex', flexDirection: 'row', marginBottom: '0.5rem' }}>
        <QueryFieldSelect schema={schema} value={value?.field} onChange={field => onChange({ field })} />
        <div style={{ margin: 'auto' }}>
          <Icon svg={require('../../icons/垃圾桶.svg')} className="array-delete" onClick={onDelete} />
        </div>
      </div>}
      {value?.field ? <QueryItemFrom {...props} fieldKey={value?.field} /> : null}
    </>
  )
}

const QueryForm = (props) => {
  const { query, schema, onChange, relation } = props

  const { t:_t1 } = useI18n()

  let error = {}
  query?.forEach(item => {
    if (item?.field && query.filter(q => q?.field == item.field)?.length > 1) {
      error = { ...error, [item.field]: _t1('且逻辑中不能存在重复字段') }
    }
  })
  const onItemChange = (i) => value => {
    const f = value.field.replace('.', '.properties.')
    if (_.get(schema.properties, f)?.type == 'boolean') {
      if (_.isNil(value?.value)) {
        value['value'] = true
      }
    }
    onChange([
      ...query.slice(0, i),
      value,
      ...query.slice(i + 1)
    ])
  }

  const onItemDelete = (i) => () => {
    onChange([
      ...query.slice(0, i),
      ...query.slice(i + 1)
    ])
  }

  const onAddQuery = () => {
    onChange([...query, {}])
  }

  return <Model schema={schema}>
    {query.map((item, i) => {
      const errorIndex = error[item.field] ? query.findLastIndex(q => q?.field == item.field) : -1
      return (
        <span key={item.field + item.method}>
          <QueryItem {...props} onChange={onItemChange(i)} onDelete={onItemDelete(i)} value={item} fieldProp={{}} />
          {errorIndex == i && <div style={{ fontSize: 12, color: '#ff4d4f' }}>{error[item.field]}</div>}
          {!relation || relation == 'and' ?
            i == query.length - 1 ? <Button onClick={onAddQuery}>+ {_t1('且')}</Button> : <div style={{ margin: '0 1rem 0.5rem 1rem' }}>{_t1('且')}</div> : null}
        </span>
      )
    })}
  </Model>
}

/**
  * @param {string} relation 逻辑关系
  * @param {boolean} unbind 不能绑定数据 
  * @param {boolean} timeRangeQuery 用于查询的时间字段是否可以定义变化范围
  * @param {boolean} DataWrap 绑定变量wrap
*/

const QueryEditor = props => {
  const { input = {}, relation, unbind, style, DataWrap } = props
  const { value = [], onChange } = input
  const [queries, setQueries] = useState(value)

  const { t:_t1 } = useI18n()

  const saveQueries = queries => {
    const qs = queries.filter(q => !_.isEmpty(q))
    setQueries(qs)
    onChange && onChange(qs)
  }

  React.useEffect(() => {
    setQueries(input.value || [])
  }, [input.value])

  const addQuery = useCallback((i, fieldName) => {
    const query = queries[i] || []
    const newQuery = [
      ...query,
      { field: fieldName }
    ]
    saveQueries([..._.set(queries, i, newQuery)])
  }, [queries])

  const onAddOrQuery = useCallback(() => {
    saveQueries([
      ...queries,
      [{}]
    ])
  }, [queries])

  const setQuery = i => query => {
    if (_.isEmpty(query)) {
      saveQueries([...queries.slice(0, i), ...queries.slice(i + 1)])
    } else {
      saveQueries([..._.set(queries, i, query)])
    }
  }

  if (_.isEmpty(queries)) {
    return <Button onClick={() => addQuery(0)}>{_t1('添加过滤条件')}</Button>
  } else {
    return queries.map((query, i) => {
      return (
        <div style={style}>
          <QueryForm {...props} query={query} onChange={setQuery(i)} />
          {!relation || relation == 'or' ?
            i == queries.length - 1 ? <Button style={{ marginLeft: '0.5rem' }} onClick={onAddOrQuery}>+ {_t1('或')}</Button> : <Divider plain>{_t1('或')}</Divider> :
            null
          }
        </div>
      )
    })
  }
}

export default QueryEditor
