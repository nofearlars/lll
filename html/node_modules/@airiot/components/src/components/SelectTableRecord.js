import React from 'react'
import { api, use } from 'xadmin'
import { TreeSelect, Select } from 'antd'
import _ from 'lodash'
import useInput from './hooks/useInput'
import useDepend from './hooks/useDepend'
import useTableId from './hooks/useTableId'
import useDropdown from './hooks/useDropdown'
import useInitOptions from './hooks/useInitOptions'
import { getLabel } from './util'

const mapperTable = item => {
  return {
    ...item,
    id: item.id,
    pId: null,
    title: item.title || item.name,
    value: item.id,
    isLeaf: false,
    selectable: false
  }
}

const hasRelate = (item, relate) => {
  for (let key of _.keys(item.schema.properties)) {
    const p = item.schema.properties[key]
    if (p.config === '关联字段' && relate.map(r => r?.table?.id).indexOf(p?.relate?.id) !== -1) {
      return true
    }
  }
  return false
}
const hasRelateTable = (item, relateTable) => {
  for (let key of _.keys(item.schema.properties)) {
    const p = item.schema.properties[key]
    if (p.config === '关联字段' && relateTable.map(r => r?.id).indexOf(p?.relate?.id) !== -1) {
      return true
    }
  }
  return false
}

const convertTreeDataTable = (list, table, relate, relateTable) => {
  let result = _.cloneDeep(list)
  if (table?.length) {
    result = result.filter(item => table.indexOf(item.id) !== -1)
  } 
  if (relate?.length) {
    result = result.filter(item => hasRelate(item, relate))
  }
  if (relateTable?.length) {
    result = result.filter(item => hasRelateTable(item, relateTable))
  }
  return result.map(mapperTable)
}

const convertTreeDataRecord = (list, pId, titlekey, child) => {
  return list.map(item => {
    return {
      id: item.id,
      pId,
      title: item[titlekey] || item.id,
      value: item.id,
      isLeaf: !child,
      isRecord: true,
      child
    }
  })
}

const convertTreeTable = (id, child) => {
  return child.map(item => {
    return {
      ...mapperTable(item),
      pId: id
    }
  })
}

const getRecordItem = ({ list, id, title, titlekey }) => {
  return list.map(item => ({ id: item.id, name: item[titlekey], table: { id, title } }))
}

const relateFilter = (schema, relate) => {
  if (relate?.length) {
    const where = {}
    for (let key of _.keys(schema.properties)) {
      const p = schema.properties[key]
      const index = relate.map(r => r?.table?.id).indexOf(p?.relate?.id)
      if (p.config === '关联字段' && index !== -1) {
        const rId = relate[index].id
        if (where[`${key}Id`]) {
          where[`${key}Id`]['$in'].push(rId)
        } else {
          where[`${key}Id`] = { "$in": [rId] }
        }
      }
    }
    if (!_.isEmpty(where)) {
      return { where }
    } else {
      return {}
    }
  }
  return {}
  
}

const SelectAllTable = (props) => {
  const { input, table, func, recordLabel, multiple, onlyId, filter, tree, relate } = props
  const [treeData, setTreeData] = useInitOptions(input?.value, mapperTable)
  const [list, setList] = React.useState([])

  const _input = useInput({ input, multiple, onlyId, list })

  const fetchTable = React.useCallback(async (table, tree, relate, relateTable) => {
    const { items: list } = await api({ name: 'core/t/schema' }).query({ fields: ['title', 'name', 'showField', 'function', 'schema'] }, { where: filter || { function: { '$regex': func } } })
    let _treeData = convertTreeDataTable(list, table, relate, relateTable)
    if (tree && _treeData?.length) {
      const { json: parentList } = await api({name: `core/t/schema/batch/relations`}).fetch('', { 
        method: 'POST', 
        body: JSON.stringify(_treeData.map(item => item.id))
      })

      _treeData = _treeData.filter((item, index) => {
        if (parentList[index].child.length) {
          _treeData[index].child = parentList[index].child
        }
        return !(parentList[index].parent && parentList[index].parent.length);
      });
    }
    setTreeData(_treeData)
  }, [])

  const fetchRecord = React.useCallback(async ({ value, schema, id, title, showField, child, isRecord }) => {
    if (isRecord) {
      const _treeData = convertTreeTable(id, child)
      setTreeData([...treeData, ..._treeData])
    } else {
      const titlekey = getLabel({ recordLabel, schema, showField })
      relateFilter(schema, relate)
      const { items: _list } = await api({ name: `core/t/${value}/d` }).query({
        fields: [titlekey]
      }, relateFilter(schema, relate))
      const _treeData = convertTreeDataRecord(_list, value, titlekey, child)
      setTreeData([...treeData, ..._treeData])
      setList([...list, ...getRecordItem({ list: _list, id, title, titlekey })])
    }
    
  }, [treeData, relate])

  const { ready, onDropdownVisibleChange, dropdownRender } = useDropdown({ fetch: async () => { await fetchTable(table, tree, relate) } })

  console.log(ready, 'ready')

  React.useEffect(() => {
    if (ready) {
      fetchTable(table, tree, relate)
    }
  }, [JSON.stringify(table), tree, relate, ready])

  return (
    <TreeSelect
      treeDataSimpleMode
      showSearch
      autoClearSearchValue
      treeNodeFilterProp='title'
      treeData={treeData}
      loadData={fetchRecord}
      {..._input}
      allowClear
      onDropdownVisibleChange={onDropdownVisibleChange}
      dropdownRender={dropdownRender}
      style={{ width: props.width || 150, minWidth: 120 }}
      {...props}
      placeholder={_t1(props?.placeholder || props?.label)}
    ></TreeSelect>
  )
}

const SelectByTableName = (props) => {
  const { table, input, recordLabel, multiple, onlyId, filter = {} } = props
  const [options, setOptions] = useInitOptions(input?.value, item => ({ label: item.title || item.name, value: item.id }))

  const { schema, id, title, showField } = use('table.schema', table)
  const [list, setList] = React.useState([])

  const _input = useInput({ input, multiple, onlyId, list })

  const fetchRecord = React.useCallback(async (table, schema, id, title, showField) => {
    const titlekey = getLabel({ recordLabel, schema, showField })
    const { items: list } = await api({ name: `core/t/${table}/d` }).query({
      fields: [titlekey]
    }, { where: filter })
    setList(getRecordItem({ list, id, title, titlekey }))
    const _options = list.map(item => ({ label: item[titlekey], value: item.id }))
    setOptions(_options)
  }, [])

  const { ready, onDropdownVisibleChange, dropdownRender } = useDropdown({ fetch: async () => { await fetchRecord(table, schema, id, title, showField) } })

  console.log(ready, 'ready')

  React.useEffect(() => {
    if (ready && schema && id && title) {
      fetchRecord(table, schema, id, title)
    }
  }, [table, schema, id, title, ready])

  return <Select options={options} {..._input} allowClear onDropdownVisibleChange={onDropdownVisibleChange} dropdownRender={dropdownRender} {...props} placeholder={_t1(props?.placeholder)} mode={multiple ? 'multiple' : null}></Select>
}

const SelectTableRecord = (props) => {
  const { table, input, multiple } = props

  // 兼容多选空值
  React.useEffect(() => {
    if (multiple && !input?.value) {
      input?.onChange && input.onChange([])
    }
  }, [input?.value, multiple])
  // 指定单表
  if (_.isString(table)) {
    return <SelectByTableName {...props} ></SelectByTableName>
    // 指定多表或不指定
  } else {
    return <SelectAllTable {...props} ></SelectAllTable>
  }
}

const SelectTableRecordField = (props) => {
  const { table, input, field } = props

  const { depend, dependRelate } = field

  const { name } = input
  // 表
  const dependValue = useDepend({ depend, name })
  // 关联记录
  const dependRelateValue = useDepend({ depend: dependRelate, name })

  const dependTable = useTableId(dependValue)

  const finalTable = dependTable || table

  let relate = null

  if (dependRelate) {
    relate = _.isPlainObject(dependRelateValue) ? [dependRelateValue] : dependRelateValue
  }

  return <SelectTableRecord {...props} {...field} table={finalTable} relate={relate}></SelectTableRecord>
}

export { SelectTableRecordField }

export default SelectTableRecord
