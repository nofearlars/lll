import { Avatar, Tree, Spin, Input, Empty, TreeSelect } from 'antd';
import React from 'react';
import { api, app, config } from 'xadmin';
import { C, Loading, Icon } from 'xadmin-ui';
import NoData from '../NoData'
import { getLabel } from '../util';

import _ from 'lodash';

const AvatarIcon = ({ icon, node }) => {
  if (icon) {
    return <Avatar size={20} shape="square" src={config('mediaUrl') + icon} style={{ margin: '0 10px 3px 0' }} />
  } else {
    return <Avatar size={20} shape="square" style={{ margin: '0 10px 3px 0' }}>
      {node ? 'N' : "M"}
    </Avatar>
  }
}
function uuid() {
  var s = [];
  var hexDigits = "0123456789abcdef";
  for (var i = 0; i < 36; i++) {
    s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
  }
  s[14] = "4";  // bits 12-15 of the time_hi_and_version field to 0010
  s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);  // bits 6-7 of the clock_seq_hi_and_reserved to 01
  s[8] = s[13] = s[18] = s[23] = "-";

  var uuid = s.join("");
  return uuid;
}

const getName = (_label) => {
  const keys = _.keys(_label)
  if (keys?.length && _.isString(keys[0])) {
    return _label[keys[0]]
  } else {
    return null
  }
}

const dataFun = (data = [], parentId, titleKey) => {
  return data.map(item => ({
    ...item,
    title: getName(item._label) || item.id,
    nodeKey: item.id,
    id: item.id || '',
    modelId: parentId,
    mark_node: parentId ? true : false,
    key: item.id + '_' + uuid(),
    parent_id: parentId,
    showicon: true,
    icon: item.icon || (item.model && item.model.icon),
    isLeaf: true
  }))
}


//models 过滤根节点数据
const modelsRootNodeFn = (data = []) => {
  const node = []
  data.map(item => {
    node.push({
      key: item.id + '_' + uuid(),
      nodeKey: item.id, title: item.title,
      showicon: true,
      ...item
    })
  })
  return node
}

const convertToNestedStructure = (arr) => {
  const idMap = new Map();

  // 创建一个 Map 对象，以存储每个对象的引用
  arr.forEach(item => {
    idMap.set(item.id, { ...item, title: item.name, key: item.id, catalog: true });
  });

  const root = [];

  // 遍历原数组来构建嵌套结构
  arr.forEach(item => {
    if (item.parentId) {
      // 如果有父对象，则将当前对象添加到其父对象的 children 数组中
      const parent = idMap.get(item.parentId);
      if (!parent.children) {
        parent.children = [];
      }
      parent.children.push(idMap.get(item.id));
    } else {
      // 如果没有父对象，则将当前对象添加到根数组中
      root.push(idMap.get(item.id));
    }
  });

  return root;
}

function populateIdMap(nestedData, idMap) {
  nestedData.forEach(item => {
    idMap.set(item.id, item);
    if (item.children) {
      populateIdMap(item.children, idMap);
    }
  });
}

const mergeTablesIntoNestedData = (nestedData, tables) => {
  nestedData = _.cloneDeep(nestedData)
  const idMap = new Map();

  // 递归地填充 idMap
  populateIdMap(nestedData, idMap);

  tables.forEach(table => {
    if (table.catalog && table.catalog.id) {
      const parent = idMap.get(table.catalog.id);
      if (parent) {
        if (!parent.children) {
          parent.children = [];
        }
        parent.children.push(table);
      }
    } else {
      nestedData.push(table);
    }
  });

  // 过滤掉没有 children 的 catalog: true 对象
  function filterCatalogItems(item) {
    if (item?.children?.length) {
      item.children = item.children.filter(filterCatalogItems);
    }
    return item.catalog!==true || item?.children?.length;
  }

  return nestedData.filter(filterCatalogItems);
}

const renderTreeNodes = (data, multiple, TreeSelects) => {
  let TreeNode = Tree.TreeNode
  if (TreeSelects) TreeNode = TreeSelect.TreeNode
  return data.map((item) => {
    if (item.children) {
      return (
        <TreeNode
          key={item.key}
          dataRef={item}
          title={item.title}
          nodeKey={item.nodeKey}
          value={item.id}
          disabled={!item.mark_node}
          icon={!item.mark_node && item.catalog !== true ? (item.icon ? <Avatar size={19} src={item?.icon} /> : <Icon className="table-type-icon" svg={require('../../icons/tableIcon/设备表.svg')}/>): null}
          isLeaf={item.isLeaf}
        >
          {renderTreeNodes(item.children, multiple, TreeSelects)}
        </TreeNode>
      )
    }
    return (<TreeNode
      dataRef={item}
      key={item.key}
      title={item.title}
      nodeKey={item.nodeKey}
      value={item.id}
      disabled={!item.mark_node}
      icon={!item.mark_node ? (item.icon ? <Avatar size={19} src={item?.icon} /> : <Icon className="table-type-icon" svg={require('../../icons/tableIcon/设备表.svg')}/>): null}
      isLeaf={item.isLeaf}
    />
    )
  })
}

const useNodeTree = (props, multiple, TreeSelect, project = []) => {

  const { tables, queryFilter, type } = props

  const [nodes, setNodes] = React.useState([])
  const [datas, setDatas] = React.useState([])
  const [searching, setSearching] = React.useState(false)
  const [searchNodes, setSearchNodes] = React.useState(null)
  const [searchValue, setSearchValue] = React.useState(null)
  const [Loadings, setLoadings] = React.useState(false)

  const updateTreeData = (list, key, children) => {
    const result = list.map((node) => {
      const _node = _.omit(node, 'uid')
      if (node?.id === key) {
        return { ..._node, children };
      }
      if (node.children) {
        return { ..._node, children: updateTreeData(node.children, key, children) };
      }
      return _node;
    });
    return result
  }


  //异步加载
  const loadData = (treeNode) => {
    return new Promise((resolve) => {
      if (treeNode.children) {
        resolve()
        return
      }
      // mark_node为资产标识 true时是models查询
      const { dataRef: { mark_node }, dataRef } = treeNode.props
      const parentId = dataRef.nodeKey
      const titleKey = getLabel({ schema: dataRef?.schema })
      const Type = mark_node ? 'Model' : 'Node'
      const urlMap = {
        Model: { name: 'core/t/schema' },
        Node: { name: `core/t/${parentId}/d` }
      }
      const whereMap = {
        Model: { 'relations.parentId': dataRef.modelId, function: { '$regex': 'device' } },
        Node: { ...(dataRef.parent_id ? { 'parentId': dataRef.parent_id } : {}), ...queryFilter }
      }
      api(urlMap[Type])
        .query({ fields: mark_node ? ['icon'] : ['modelId', 'id', 'icon', 'model.icon'].concat(titleKey ? [titleKey] : []) }, { where: whereMap[Type] })
        .then(({ items }) => {
          const children = dataFun(items, parentId, titleKey)
          const newNodes = updateTreeData(nodes, parentId, children)
          const _nodes = modelsRootNodeFn([...newNodes])
          setNodes(_nodes)
          setSearchNodes(_nodes)
          setDatas(_nodes)
          resolve()
        })
    })
  }

  const onSearch = value => {
    setSearchValue(value)
    onDoSearch(value)
  }
  const onDoSearch = React.useCallback(_.debounce(value => {
    if (value) {
      setSearching(true)
      setSearchNodes([])
      const or = [{ id: { like: value } }, { title: { like: value } }]
      api('Table').query({ limit: 200, fields: ['schema', 'id', ...project] }, { where: { or } })
        .then(({ items }) => {
          setSearching(false)
          const newData = [...modelsRootNodeFn(items)]
          setSearchNodes(newData)
          setDatas(newData)
          setNodes(newData)
        }).catch(err => {
          setSearching(false)
          setSearchNodes([])
        })
    } else {
      setSearching(false)
      setSearchNodes(null)
      setSearchValue([])
      ModelQuery()
    }
  }, 500), [])

  // React.useEffect(() => {
  //   if (props.value) {
  //     setNodes(dataFun([props.value]))
  //   }
  // }, [props.value])

  React.useEffect(() => {
    const { initialValue: node, inputValue } = props
    setLoadings(true)
    if (node) {
      setSearchValue(node.name || [])
      if (node.model) {
        setSearchNodes(dataFun([node]))
      } else {
        if (node.id && inputValue?.table) {
          const table = _.isObject(inputValue?.table) ? inputValue?.table?.id : inputValue?.table
          table && api({ name: `core/t/${table}/d` })
            .get(node.id)
            .then(data => setSearchNodes(dataFun([{ ...data,...node}], table)))
        }
      }
    }
    // 点击输入请求
    if (TreeSelect) return
    ModelQuery()
  }, [ JSON.stringify(tables), JSON.stringify(queryFilter) ])

  React.useEffect(() => {
    if (type) {
      setLoadings(true)
      setSearchNodes(null)
      setSearchValue(null)
      ModelQuery()
    }
  }, [type])

  const ModelQuery = (model) => {
    const where = { function: { '$regex': 'device' }}
    if (tables?.length) {
      where['id'] = { $in: (tables || []).map(t => t.id) }
    }
    api({ name: 'core/t/schema' })
      .query({
        fields: ['relations', 'id', 'icon', 'device', 'warning', 'schema', 'catalog']
      },
        { where }
      )
      .then(({ items }) => {
        if (type === '分组') {
          CatalogQuery().then(({ items: catalogs }) => {
            const tables = modelsRootNodeFn(items)
            const catalogNodes = convertToNestedStructure(catalogs)
            const mergeNodes = mergeTablesIntoNestedData(catalogNodes, tables)
            setNodes(mergeNodes)
            setLoadings(false)
          })
        } else {
          const tables = modelsRootNodeFn(items)
          console.log(tables, 'tables')
          setNodes(tables)
          setLoadings(false)
        }
      })
  }

  const CatalogQuery = () => {
    const fields = ['parent', 'order', 'icon']
    const where = { "type": 'table' }

    return api({ name: 'core/catalog' }).query({ fields }, { where })
  }

  const children = renderTreeNodes(searchNodes != null ? searchNodes : (nodes || []), multiple, TreeSelect)

  const notFoundContent = searching ? <div style={{ textAlign: 'center' }}><Spin size="small" /></div> : <NoData />

  return { loadData, onSearch, notFoundContent, children, searchValue, nodes, ModelQuery, datas, Loadings }
}

export default props => {
  const { loadData, onSearch, notFoundContent, children, searchValue, nodes, Loadings } = useNodeTree(props)
  const { t:_t1 } = useI18n()
  return (<>
    {
      props.showSearch ? <Input.Search
        allowClear

        style={{ marginBottom: 5 }}
        value={searchValue}
        placeholder={_t1("输入表名称或编号")}
        onChange={e => onSearch(e.target.value)} />
        : null
    }
    {
      props.showSearch ? Loadings ? <Loading /> : children.length > 0 ? (
        <Tree
          showIcon
          virtual={false}
          onSelect={props.onSelect}
          showLine={{ showLeafIcon: false }}
          loadData={loadData} notFoundContent={notFoundContent}
        >
          {children}
        </Tree>
      ) : <Empty image={require('../../imgs/暂无数据空.png')}/>
        : (<Tree showLine showIcon defaultExpandAll onSelect={props.onSelect} loadData={loadData}
          notFoundContent={notFoundContent}
        >
          {children}
        </Tree>)
    }

  </>
  )
}

export { useNodeTree }
