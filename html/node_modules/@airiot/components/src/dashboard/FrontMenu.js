import React, { useState, useEffect } from 'react'
import _ from 'lodash'
import { Button, Modal, Menu, Avatar, TreeSelect } from 'antd'
import { app, use, config, api } from 'xadmin'
import { RightOutlined, LeftOutlined } from '@ant-design/icons';
import MenuEditTree from '../components/MenuEditTree'
import { Icon } from 'xadmin-ui'
import './style.css'
import SelectMenu from './SelectMenu'

const onAuthorization = (permission, _user) => {
  const user = _user || app.context?.user
  if (!permission || _.isEmpty(permission)) { return true }
  if (user && user.isSuper) { return true }
  if (user && user.permissions) {
    if (_.isArray(permission)) {
      return !_.some(permission, p => user.permissions.indexOf(p) == -1)
    } else if (_.isFunction(permission)) {
      return permission(user)
    } else {
      return user.permissions.indexOf(permission) > -1
    }
  } else {
    return false
  }
}

const SettingsMenuField = props => {
  const { input } = props
  let type = props?.type
  const [visible, setVisible] = useState(false)

  const showModal = () => setVisible(true)

  const handleOk = e => {
    setVisible(false)
  }

  const handleCancel = e => setVisible(false)

  return (
    <div>
      <Button onClick={showModal}><Icon type="setting" /></Button>
      <Modal title={<span style={{ padding: '.5rem' }}>{_t1('菜单')}</span>} width={800} bodyStyle={{ padding: 20 }} footer={null} visible={visible} onOk={handleOk} onCancel={handleCancel}>
        <MenuEditTree input={input} type={type} handleCancel={() => { }} />
      </Modal>
    </div>
  )
}

const MainMenu = (props) => {
  const { canClick = true, menu, update, data, inlineCollapsed, defaultOpenKeys, mode, accordion } = props
  const { width = '100%', trigger, bgColor, textSize, textColor, icon, itemHeight, itemMargin, childItemMargin, childItemHeight } = props.config
  const { user, user: { permissions, rolesObjList } } = use('auth.user')
  const [value, setValue] = React.useState(menu)
  const [collapsed, setCollapsed] = useState(false);
  const [openKeys, setOpenKeys] = React.useState([])
  const [selectedKeys, setSelectedKeys] = useState([]);
  const setHistorys = use('navTab.historys.set')
  useEffect(() => {
    const storedSelectedKeys = localStorage.getItem('selectedKeys');
    if (storedSelectedKeys) {
      setSelectedKeys(JSON.parse(storedSelectedKeys));
    }
  }, []);

  const toggleCollapsed = () => {
    setCollapsed(!collapsed);
    // console.log();
  };
  const onMenuSelect = ({ key }) => {
    setSelectedKeys([key]);
    localStorage.setItem('selectedKeys', JSON.stringify([key]));
  };


  const onOpenChange = (keys) => {
    if (accordion) {
      const subkeys = menu.map(item => { return item.key })
      const latestOpenKey = keys.find((key) => openKeys?.indexOf(key) === -1);
      if (subkeys.indexOf(latestOpenKey) === -1) {
        setOpenKeys(keys);
      } else {
        setOpenKeys(latestOpenKey ? [latestOpenKey] : []);
      }
    } else {
      setOpenKeys(keys)
    }
  }


  // const { user, user: { permissions, rolesObjList } } = use('redux', state => ({ user: state.user }))

  // 权限过滤
  // const configMenu = user?.isSuper ? menu : menu && menu.length > 0 ? menu.filter(f => {
  //   return permissions.indexOf(f.permission) >= 0
  // }) : null

  const isSuper = user?.isSuper || user?.isAdmin

  React.useEffect(() => {
    (async () => {
      const fields = ['isDefault', 'settings', 'routes', 'homeRoute', 'name']
      let wheres = { isDefault: true }
      if (!isSuper) {
        let defaultItem = await api({ name: 'core/site' }).query({ fields }, { wheres }).then(({ items }) => items?.[0])
        const configMenu = menu
        let userMenu = null, rolesMenu = null
        if (user?.mainmenu?.length && defaultItem?.id) {
          let filterUserMenu = user.mainmenu.filter(val => val?.site?.id == defaultItem?.id)?.[0]?.menu
          if (filterUserMenu?.length) userMenu = filterUserMenu
        }
        if (rolesObjList?.length && defaultItem?.id) {
          rolesMenu = rolesObjList.map(role => {
            if (role?.mainmenu?.length) {
              let filterRoleMenu = role.mainmenu.filter(val => val?.site?.id == defaultItem?.id)?.[0]?.menu || []
              return filterRoleMenu
            } else {
              return []
            }
          }).reduce((prev, role) => (_.unionBy(prev, role, 'title')), [])
        }

        const mergeMenu = userMenu && userMenu.length > 0 ? userMenu : rolesMenu
        const menus = mergeMenu && mergeMenu.length > 0 ? mergeMenu : configMenu
        setValue(menus)
      } else {
        setValue(menu)
      }
    })()
  }, [isSuper, JSON.stringify(user), JSON.stringify(menu)])

  // let value = menu
  // if (!isSuper) {
  //   const configMenu = menu
  //   const userMenu = user?.mainmenu
  //   const rolesMenu = rolesObjList && rolesObjList.length > 0 ? rolesObjList
  //     .map(role => role.mainmenu ? role.mainmenu : [])
  //     .reduce((prev, role) => (_.unionBy(prev, role, 'title')), [])
  //     : null
  //   const mergeMenu = userMenu && userMenu.length > 0 ? userMenu : rolesMenu
  //   value = mergeMenu && mergeMenu.length > 0 ? _.intersectionBy(configMenu, mergeMenu, 'title') : configMenu
  // }

  const MenuClick = (item) => {
    const { url, iframUrl } = item
    localStorage.setItem('selectedKeys', JSON.stringify(selectedKeys));
    if (url && canClick) {
      setHistorys(h => _.compact(_.uniqBy([...(h || []), item], 'key')))
      if (url.indexOf('http') >= 0) {
        if (iframUrl && update) {
          update((state) => {
            return {
              ...state,
              ['menuforIfram']: url
            }
          })
        } else {
          window.open(url)
        }
      } else {
        if (!iframUrl) {
          app.go(url)
        } else {
          update && update((state) => {
            return {
              ...state,
              ['menuforIfram']: url
            }
          })
        }
      }
    }
  }

  const menustyle = { color: textColor }
  const style = { margin: `0 ${itemMargin}px`, fontSize: textSize }

  const GetMenu = (menuTreeData) => {
    if (!menuTreeData || _.isEmpty(menuTreeData)) return
    return menuTreeData.map(item => {
      let titileIcon = <span className="dashboar_menu"><img /></span>
      let src = item.icon
      if (src) {
        if (_.isString(src) && src.indexOf('/') > -1) {
          titileIcon = <span className="dashboar_menu"><img src={config('mediaUrl') + src} /></span>
        } else {
          const icons = app.get('icons')
          const icon = _.find(icons, item => item.name == src)
          if (icon) { titileIcon = <Icon svg={icon.url} /> } else { titileIcon = item.icon }
        }
      }
      if (item.iframUrl && item.url.indexOf('fullscreen=true&loadwarning=false') == -1) {
        item.url = item.url.indexOf('?') == -1 ? item.url + '?fullscreen=true&loadwarning=false' : item.url + '&newData.url'
      }
      if (!onAuthorization(item.permission)) {
        return null
      }
      if (item.children && item.children.length > 0) {
        return (
          <Menu.SubMenu title={
            <a onClick={() => (item.url || item.iframUrl) && MenuClick(item)}
              style={style}>
              {icon ? titileIcon : null}
              <span style={menustyle}>{item.title}</span>
            </a>}
            popupClassName={'dashboar_menu_popup'}
            key={item.key}
          >
            {GetMenu(item.children)}
          </Menu.SubMenu>
        )
      }
      return (
        <Menu.Item key={item.key}>
          <a onClick={() => (item.url || item.iframUrl) && MenuClick(item)} style={style}>
            {icon ? titileIcon : null}
            <span style={{ ...menustyle }}>{item.title}</span>
          </a>
        </Menu.Item>
      )
    })
  }
  React.useEffect(() => {
    if (defaultOpenKeys) {
      setOpenKeys(_.isArray(defaultOpenKeys) ? defaultOpenKeys : [defaultOpenKeys])
    }
  }, [defaultOpenKeys])

  useEffect(() => {
    const storedSelectedKeys = localStorage.getItem('selectedMenu');
    if (storedSelectedKeys) {
      setSelectedKeys(JSON.parse(storedSelectedKeys));
    }
  })
  React.useEffect(() => {
    const handleRouteChange = () => {
      const currentPath = window.location.hash.substring(1);
      const selectedMenu = findSelectedKeyByPath(menu, decodeURI(currentPath));
      const selectedKey = selectedMenu?.key
      setSelectedKeys(selectedKey ? [selectedKey] : []);
      setHistorys(h => _.compact(_.uniqBy([...(h || []), selectedMenu], 'key')))
    };

    handleRouteChange();

    window.addEventListener("hashchange", handleRouteChange);

    return () => {
      window.removeEventListener("hashchange", handleRouteChange);
    };
  }, [menu]);

  const findSelectedKeyByPath = (menuItems, path) => {

    const menus = menuItems?.reduce((p, c) => {
      if (!_.isEmpty(c.children)) {
        return [...p, c, ...c.children]
      } else {
        return [...p, c]
      }
    }, [])
    const getPathPrefix = (path) => {
      if (!path) return
      if (menus?.find(m => m?.url == path)) {
        return menus?.find(m => m?.url == path)
      } else {
        return getPathPrefix(path?.substring(0, path?.lastIndexOf("/")))
      }
    }
    return getPathPrefix(path)
  };
  return (
    <>
      <Menu mode={props.mode} className="front-menu" triggerSubMenuAction={trigger} inlineCollapsed={collapsed}
        onOpenChange={onOpenChange}
        openKeys={openKeys}
        selectedKeys={selectedKeys}
        onSelect={onMenuSelect}
        // getPopupContainer={triggerNode => triggerNode.parentNode || document.body}
        style={{ width, backgroundColor: bgColor, lineHeight: `${itemHeight}px`, borderRight: 0 }}>
        {GetMenu(value)}
      </Menu>
      {mode == 'inline' ? (inlineCollapsed ? (collapsed ? <RightOutlined onClick={toggleCollapsed} style={{ position: 'absolute', bottom: '10px', width: "100%" }} />
        : <LeftOutlined onClick={toggleCollapsed} style={{ position: 'absolute', bottom: '10px', width: "100%" }} />) : ''

      ) : ''
      }
      <style>{`.dashboar_menu_popup>ul.ant-menu{
        background:${bgColor};
        }`}</style>
      <style>{`.front-menu .ant-menu-sub li{
        height:${childItemMargin}px !important;
        line-height:${childItemMargin}px !important;
        }`}</style>
      <style>{`.front-menu .ant-menu-sub{
        height:${childItemHeight}px !important;
        overflow: hidden auto !important;
        }`}</style>
    </>
  )
}

const FrontMenuComponent = props => {
  const {
    mode = 'horizontal', bgColor, dashboardMode, icon, width, itemHeight,
    itemMargin, textSize, textColor, menu, childItemMargin, childItemHeight, trigger, inlineCollapsed, defaultOpenKeys, accordion
  } = props
  const [data, update] = use('dashboard.customVar')

  const { t: _t1 } = useI18n()

  if (!data?.menuforIfram && update) {
    update((state) => {
      return {
        ...state,
        ['menuforIfram']: '/'
      }
    })
  }

  if (dashboardMode && _.isEmpty(menu)) {
    return <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', fontSize: 12, color: '#999' }}>{_t1('请进行菜单设置')}</div>
  }
  // console.log(menu, '首页母版')
  return (<MainMenu
    name={'frontmenu'}
    menu={menu} update={update} data={data}
    // mode={mode}
    // 数据兼容
    mode={mode == '水平' ? 'horizontal' : mode == '垂直' ? 'inline' : mode}
    config={{ icon, width, bgColor, textColor, itemHeight, itemMargin, textSize, childItemMargin, childItemHeight, trigger }}
    canClick={!dashboardMode}
    inlineCollapsed={inlineCollapsed}
    defaultOpenKeys={defaultOpenKeys}
    accordion={accordion}
  />)
}


const paramSchema = {
  type: 'object',
  properties: {
    menu: {
      type: 'object',
      title: _r('菜单设置'),
      properties: {}
    },
    mode: {
      type: 'string',
      title: _r('方向'),
      enum: ['vertical', 'horizontal', 'inline'],
      enum_title: [_r('垂直'), _r('水平'), _r('内嵌')]
    },
    inlineCollapsed: {
      type: 'boolean',
      title: '展开折叠',
      field: {
        formEffect: (form) => {
          form.useField('mode', ({ value }) => {
            setTimeout(() => {
              if (value == 'inline') {
                form.setFieldData('inlineCollapsed', { display: true })
              } else {
                form.setFieldData('inlineCollapsed', { display: false })
              }
            })
          })
        }
      },
    },
    accordion: {
      type: 'boolean',
      title: '手风琴效果',
      description: '开启手风琴效果，只允许一个父级菜单为展开状态',
      field: {
        effect: (f, form) => {
          const { initialValues, values } = form.getState()
          if (f.value && _.isArray(values?.defaultOpenKeys)) {
            form.change('defaultOpenKeys', null)
          }
        }
      }
    },
    defaultOpenKeys: {
      type: 'string',
      title: '默认展开',
      description: '开启手风琴效果，默认展开只允许一个父级菜单',
      field: {
        component: props => <SelectMenu {...props} />
      }
    },
    trigger: {
      type: 'string',
      title: _r('触发方式'),
      enum: ['click', 'hover'],
      enum_title: [_r('点击'), _r('经过')]
    },
    icon: {
      title: _r('显示图标'),
      type: 'boolean',
    },
    bgColor: {
      title: _r('背景色'),
      type: 'string',
      fieldType: 'color'
    },
    width: {
      title: _r('整体宽度'),
      type: 'string',
      fieldType: 'unit'
    },
    itemHeight: {
      title: _r('选项高度'),
      type: 'number',
    },
    itemMargin: {
      title: _r('选项间距'),
      type: 'number',
    },
    textSize: {
      title: _r('字号'),
      type: 'number',
    },
    textColor: {
      title: _r('文字颜色'),
      type: 'string',
      fieldType: 'color'
    },
    childItemHeight: {
      title: _r('子菜单高度'),
      type: 'number',
    },

    childItemMargin: {
      title: _r('子菜单选项高度'),
      type: 'number',
    },

  },
  form: [{ key: 'menu', component: SettingsMenuField }, '*'],
  formEffect: form => {
    form.useField('mode', state => {
      let value = state.value
      if (value == 'inline') {
        form.setFieldData('defaultOpenKeys', { display: true })
        form.setFieldData('accordion', { display: true })
      } else {
        form.setFieldData('defaultOpenKeys', { display: false })
        form.setFieldData('accordion', { display: false })
      }
      if (value == 'vertical' || value == 'horizontal') {
        form.change('defaultOpenKeys', null)
      }
    })
  },
}

const FrontMenu = {
  title: _r('菜单'),
  category: ['页面元素', '导航栏'],
  icon: require('../icons/菜单.svg'),
  component: FrontMenuComponent,
  initLayout: { width: 260, height: 80 },
  initParam: { mode: '水平', icon: true },
  paramSchema,
  theme: [
    { selector: '.ant-menu', title: _r('菜单样式') }
  ]
}
export default FrontMenu

export { MenuEditTree, SettingsMenuField }
