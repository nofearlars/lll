import React from 'react';
import { api, config, use, StoreWrap } from 'xadmin';
import _ from 'lodash'
import { notification, Button, Popconfirm, message, Form, Modal } from 'antd'
import BackupContent from './BackupContent'
import PostgesCont from './PostgesCont'
import { SchemaForm } from 'xadmin-form';
import { HasPermission } from 'xadmin-auth'
import { C, Icon } from 'xadmin-ui'


const groupProps = {
    wrapperCol: {
        xs: { span: 24, offset: 0 },
        sm: { span: 18, offset: 5 }
    }
}

const RestoreBtnChildren = ({ record, onLogout }) => {
    const { t: _t1 } = useI18n()
    const [visible, setVisible] = React.useState(false);
    const [restoreData, setRestoreData] = React.useState();
    const [state, setState] = React.useState(null);
    const [id, setId] = React.useState(null);
    const [apii, contextHolder] = notification.useNotification();
    const interval = React.useRef()
    const { modelDispatch } = use('model')
    let style = {
        background: '#f59a23',
        color: "#ffffff"
    }
    const getRestoreData = () => {
        api({ name: 'core/backup/' + record.id })
            .fetch('', {})
            .then(({ status, json }) => {
                if (status == 200) {
                    let temp = _.isString(json.item) ? JSON.parse(json.item) : json.item
                    setRestoreData({ ...json, item: Object.keys(temp).filter(item => temp[item] && item) })
                } else {
                    message.error(arg.message)
                }
            })
    }
    const schema = {
        type: 'object',
        properties: {
            item: {
                type: 'array',
                title: _r('备份内容'),
                field: {
                    component: (props) => <BackupContent {...props} data={record.item} type={'restore'} />
                },
                items: {}
            },
            mongoItem: {
                type: 'array',
                title: _r('postgres内容'),
                field: {
                    component: (props) => <PostgesCont {...props} data={record.item} type={'mongoItem'} />,
                    validate: (value, form) => {
                        if (form?.item?.includes("mongodb")) {
                            return _.isEmpty(value) ? 'postgres内容必填' : null
                        }
                        return null
                    }
                },
                items: {}
            },
            itemType: {
                type: 'number',
                title: _r('还原规则'),
                enum: [0, 1, 2],
                enum_title: ['覆盖重复数据新增', '不覆盖重复数据新增', '清除后新增'],
                field: {
                    validate: (value, form) => {
                        if (form?.item?.includes("mongodb")) {
                            return _.isNumber(value) ? null : '还原规则必填'
                        }
                        return null
                    }
                }
            }
        },
        required: ['item'],
        formEffect: (form) => {
            form.useField('item', ({ value }) => {
                const isMongo = !!value?.includes('mongodb')
                form.setFieldData('mongoItem', { display: isMongo })
                form.setFieldData('itemType', { display: isMongo })
            })
        }
    }
    const onRestore = (data) => {
        let obj = {}, moduleRules = {}
        data.item.map(item => { obj[item] = true })
        data.mongoItem.map(item => { moduleRules[item] = data?.itemType })
        api({ name: 'core/backup/import' })
            .fetch('?query=' + JSON.stringify({ moduleRules, item: obj, id: record.id, name: data.name }), {})
            .then(({ status, json }) => {
                if (status == 200) {
                    setId(json.id)
                    showTest(json.id)
                    setVisible(false)
                } else {
                    message.error(arg.message)
                }
            }).catch(err => console.log(err.message))
    }

    if (state == 'succeed') {
        clearInterval(interval.current)
        setState(null)
        message.success(_t1('还原成功，5秒后自动跳转至登录页面，需要重新登录还原数据才会生效'))
        notification.close('key')
        setTimeout(() => {
            onLogout && onLogout()
        }, 5000)
    }
    if (state == 'fail') {
        clearInterval(interval.current)
        setState(null)
        notification.close('key')
    }

    const showTest = (id) => {
        interval.current = setInterval(() => {
            status != 'succeed' && api({ name: "core/backup/" + id })
                .fetch('')
                .then(({ json: { status, log } }) => {
                    setState(status)
                    if (status == 'fail') message.error(log)
                    if (status == 'succeed') {
                        clearInterval(interval.current)
                        onLogout && onLogout()
                    }
                }).catch(err => console.log(err.message))
        }, 500)
        notification.open({
            message: ``,
            key: 'key',
            description: '还原中...',//<Context.Consumer>{({ name }) => `Hello, ${name}!`}</Context.Consumer>,
            placement: 'topRight',
            closeIcon: <></>,
            btn: <></>,
            icon: <Icon svg={require('../icon/upload.svg')} />,
            style: { background: '#02a7f0', color: '#ffffff' },
            duration: null
        });
    }

    const ChildComponent = (props) => {
        const { children, form, handleSubmit, invalid } = props
        return (<>
            <Form handleSubmit={handleSubmit}>
                {children}
                <Form.Item {...groupProps}>
                    <HasPermission FailureComponent={null} permission='backup.restore'>
                        <Button type="primary" disabled={invalid} onClick={() => {
                            onRestore(form.getState().values)
                        }}>{_t1('确定')}</Button>
                    </HasPermission>
                    <Button style={{ marginLeft: 5 }} onClick={() => {
                        setVisible(false)
                    }}>{_t1('取消')}</Button>
                </Form.Item>
            </Form>
        </>)
    }

    return (<>
        <Modal width={'50%'}
            title={_t1('还原内容')}
            visible={visible}
            footer={[]}
            onCancel={() => setVisible(false)}
        >
            <C is="I18nSchemaForm"
                schema={schema}
                initialValues={restoreData}
                component={ChildComponent}
            />
        </Modal>
        {contextHolder}
        <Popconfirm
            title={_t1("还原后平台中的数据将会被替换成还原文件中的数据，请谨慎操作!")}
            onConfirm={() => {
                getRestoreData()
                setVisible(true)
            }}
            overlayStyle={{ width: 320 }}
            okText={_t1('还原')}
            cancelText={_t1('取消')}>


            <Button style={style}>{_t1('还原')}</Button>
        </Popconfirm>
    </>
    )
}

const RestoreBtn = ((props) => {
    let user = {}
    try { user = use('auth.user') } catch (err) { }
    return <RestoreBtnChildren {...props} />
})

export default RestoreBtn