import { Avatar, Empty, TreeSelect } from 'antd';
import _ from 'lodash';
import React from 'react';
import { api, app, config } from 'xadmin';
import { Icon } from 'xadmin-ui';
import './BaseSelect.css'

const { TreeNode } = TreeSelect

const AvatarIcon = (props) => {
  if (props.icon) {
    return <Avatar size={20} shape="square" src={config('mediaUrl') + props.icon} style={{ margin: '0 10px 3px 0' }} />
  } else {
    return <Avatar size={20} shape="square" style={{ margin: '0 10px 3px 0' }}>M</Avatar>
  }
}

const convert_data = (models, vs) => {
  let newData = []
  let newModel = {}
  models && models.forEach(model => {
    if (model?.id) {
      newModel[model?.id] = model
    }
  })
  vs.map(v => {
    if (newModel[v?.value]) {
      newData.push(newModel[v?.value])
    }
  })
  return newData
}

class SelectTree extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();
  }
  renderTreeNodes = (data, prefix) => {
    const { filter = [] } = this.props
    if (data) {
      return data.map((item, i) => {
        const id = item.id || item._id
        const disabled = _.some(filter, (ele) => ele && ele.id == id)
        if (prefix && prefix.indexOf(id) >= 0) return
        if (item.child) {
          return (
            <TreeNode
              disabled={disabled}
              isLeaf={false}
              icon={<AvatarIcon icon={item.icon} />}
              title={item.name}
              key={id + '&' + prefix}
              nodeKey={id}
              value={id}
              dataRef={item}>
              {this.renderTreeNodes(item.child, prefix ? prefix + '-' + item.id : item.id)}
            </TreeNode>
          )
        } else {
          return (<TreeNode
            disabled={disabled}
            isLeaf={true}
            icon={<AvatarIcon icon={item.icon} />}
            title={item.name}
            key={id + '&' + prefix}
            nodeKey={id}
            value={id}
            dataRef={item}>
          </TreeNode>)
        }
      })
    }
  }
  onChange = (v) => {
    const { models, onChange, value } = this.props
    let model
    if (!v) {
      model = v
    }
    if (v && _.isArray(v)) {
      // 兼容数据 当联动切换时数据格式不同
      const val = _.isArray(value) ? value : [value]
      const ms = _.isArray(models) ? models : [models]
      // 取出模型原始数据 并按照选择顺序排序
      model = convert_data([...ms, ...val || []], v)
    }
    if (v && _.isPlainObject(v)) {
      model = models.filter(item => (item.id || item._id) == v.value)
    }

    onChange(model)
  }
  onDropdownVisibleChange = (v) => {
    const { loadData } = this.props
    if (v) {
      loadData()
    }
  }
  componentDidMount() {
    const { loadData } = this.props
    loadData()
  }
  render() {
    const { showIcon, treeData, models, value, width, loading, multiple, placeholder, maxTagCount, disabled, treeCheckable } = this.props

    let selected
    if (value) {
      if (_.isArray(value) && !_.isEmpty(value)) selected = _.compact(value).map(item => ({ value: item.id || item._id, label: item.name }))
      if (_.isString(value) && !_.isEmpty(value)) selected = [{ value }]
      if (_.isPlainObject(value) && !_.isEmpty(value)) selected = [{ value: value.id || value._id, label: value.name }]
    } else {
      selected = []
    }
    const props = loading ? {
      suffixIcon: <Icon type="loading" />,
    } : {}

    return (
      <TreeSelect
        treeIcon={showIcon}
        allowClear
        disabled={disabled}
        multiple={multiple}
        maxTagCount={maxTagCount}
        treeCheckable={treeCheckable}
        dropdownMatchSelectWidth={false}
        getPopupContainer={triggerNode => { return triggerNode }}
        showCheckedStrategy={treeCheckable ? TreeSelect.SHOW_ALL : TreeSelect.SHOW_CHILD}
        notFoundContent={loading ? <Icon type="loading" style={{ width: 14, display: 'block', margin: '0 auto' }} /> : <C is='NoData' style={{ padding: 20 }} />}//<Empty image={require('./../icon/homeIcon/noData.png')} imageStyle={{ height: 100 }} description={_t1('暂无数据')}></Empty>}
        {...props}
        showSearch={true}
        treeNodeFilterProp={'title'}
        style={{ minWidth: width || 160, width: '100%' }}
        value={selected || []}
        dropdownStyle={{ maxHeight: 300, overflow: 'auto', marginRight: '20px', width: '100%' }}
        placeholder={placeholder ? placeholder : '请选择...'}
        treeDefaultExpandAll
        labelInValue
        onChange={this.onChange}
        onDropdownVisibleChange={this.onDropdownVisibleChange}
      >
        {this.renderTreeNodes(treeData ? treeData : models)}
      </TreeSelect>
    )
  }
}

const data_convert_icon = (data) => {
  if (!data) return []
  return data.map(item => {
    if (item.child) {
      return {
        ..._.omit(item, 'icon'), child: data_convert_icon(item.child)
      }
    } else {
      return _.omit(item, 'icon')
    }
  })
}
class BaseSelect extends React.Component {
  state = {
    treeData: [],
    models: this.props.initialValue || [],
    loading: false
  }

  loadData = () => {
    this.setState({ loading: true })
    const { modelName, dataFilter, project, insideFilter = {} } = this.props
    const f = project ? project : []
    let schema = app.get('models')[modelName]
    const filter = { fields: ['name', 'icon', ...f] }

    // 不加这句，parent会自动变成parentId，当为空不为空时，只能用parent
    for (let key in insideFilter) {
      if (insideFilter[key]?.nin || insideFilter[key]?.in) schema.properties[key].nullFilter = true
    }

    api({ ...schema }).query(filter, { where: insideFilter ?? {} }).then(({ items }) => {
      const treeData = dataFilter && _.isFunction(dataFilter) ? dataFilter(items) : items
      this.setState({
        treeData: treeData,
        models: data_convert_icon(items),
        loading: false
      })
    })
  }

  render() {
    const { treeData, models, loading } = this.state
    const props = {
      ...this.props,
      treeData,
      models,
      loading,
      loadData: this.loadData
    }
    return <SelectTree  {...props} />
  }
}

export default BaseSelect
