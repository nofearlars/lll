
import React, { useEffect, useState } from 'react'
import { use } from 'xadmin'
import _ from 'lodash'
import { SchemaForm } from 'xadmin-form'
import { Popover, message, Button, Table, Empty, Popconfirm, Form, Modal, Checkbox } from 'antd'
import { DndProvider, DragSource, DropTarget } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';
import { Icon, C } from 'xadmin-ui'
// import NoData from './../../components/NoData'

let dragingIndex = -1;

class BodyRow extends React.Component {
  render() {
    const { isOver, connectDragSource, connectDropTarget, moveRow, ...restProps } = this.props;
    const style = { ...restProps.style, cursor: 'move' };

    let { className } = restProps;
    if (isOver) {
      if (restProps.index > dragingIndex) {
        className += ' drop-over-downward';
      }
      if (restProps.index < dragingIndex) {
        className += ' drop-over-upward';
      }
    }

    return connectDragSource(
      connectDropTarget(<tr {...restProps} className={className} style={style} />),
    );
  }
}

const rowSource = {
  beginDrag(props) {
    dragingIndex = props.index;
    return {
      index: props.index,
    };
  },
};

const rowTarget = {
  drop(props, monitor) {
    const dragIndex = monitor.getItem().index;
    const hoverIndex = props.index;

    // Don't replace items with themselves
    if (dragIndex === hoverIndex) {
      return;
    }

    // Time to actually perform the action
    props.moveRow(dragIndex, hoverIndex);

    // Note: we're mutating the monitor item here!
    // Generally it's better to avoid mutations,
    // but it's good here for the sake of performance
    // to avoid expensive index searches.
    monitor.getItem().index = hoverIndex;
  },
};

const DragableBodyRow = DropTarget('row', rowTarget, (connect, monitor) => ({
  connectDropTarget: connect.dropTarget(),
  isOver: monitor.isOver(),
}))(
  DragSource('row', rowSource, connect => ({
    connectDragSource: connect.dragSource(),
  }))(BodyRow),
);

class DragSortingTable extends React.Component {


  constructor(props) {
    super(props);
    this.state = {
      data: props.dataSource,
    }
  }

  components = {
    body: {
      row: DragableBodyRow,
    },
  };

  static getDerivedStateFromProps(props, state) {
    const { dataSource } = props
    if (dataSource != state.data) {
      return { data: dataSource }
    }
  }

  swapArr = (arr, index1, index2) => {
    arr.splice(index2, 0, arr.splice(index1, 1)[0])
    return arr;
  }

  moveRow = (dragIndex, hoverIndex) => {
    // console.log(dragIndex, hoverIndex)
    const { data } = this.state;
    const updates = this.swapArr([...data], dragIndex, hoverIndex)
    this.props.setDataSources([...updates] || [])
    this.setState({ data: [...updates] });
  };

  render() {
    return (
      <DndProvider backend={HTML5Backend}>
        <Table {...this.props} className="DragSortingTable"
          columns={this.props.columns}
          dataSource={this.state.data}
          locale={{
            emptyText: <C is='NoData' style={{ padding: 20 }} />//<NoData />
          }}
          components={this.components}
          onRow={(record, index) => ({
            index,
            moveRow: this.moveRow,
          })}
        />
      </DndProvider>
    );
  }
}

function guid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    let r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

const schema = {
  type: 'object',
  properties: {
    name: {
      title: '类型名称',
      type: 'string'
    },
  },
  form: ['name'],
  required: ['name']
}


const NodeKind = ({ input: { onChange } }) => {

  const { t: _t1 } = useI18n()
  const [visible, setVisible] = React.useState(false)
  const [initData, setInitData] = React.useState(null)
  const [editData, setEditData] = React.useState(null)
  const { settings: { nodeconfig } } = use('settings')
  const [dataSource, setDataSources] = React.useState(nodeconfig && nodeconfig.nodekind || [])

  const columns = [
    {
      title: _r('种类名称'),
      dataIndex: 'name',
      editable: true,
    },
    {
      title: _r('操作'),
      dataIndex: 'operation',
      render: (text, record) => ([
        <div style={{ textAlign: 'center' }}>
          <a style={{ marginRight: '1rem' }} onClick={() => onEdit(record)}><Icon type="edit" /></a>
          <Popconfirm title={_t1('确认删除?')} onConfirm={() => handleDelete(record.id)}>
            <a><Icon type="delete" /></a>
          </Popconfirm>
        </div>
      ]
      ),
    }
  ]

  useEffect(() => {
    onChange(dataSource)
  }, [dataSource])

  useEffect(() => {

    if (nodeconfig && nodeconfig.warningkind) setDataSources(nodeconfig.warningkind)
  }, [])

  const handleDelete = (id) => setDataSources(dataSource.filter(item => item.id !== id))

  const onEdit = (record) => {
    setVisible(true)
    setEditData(record)
    setInitData(record)
  }

  const addWarningKind = (values) => {
    let newData = _.clone(dataSource)
    if (editData) {
      let indexs = _.findIndex(newData, (item) => (item.id == editData.id))
      newData[indexs] = values
      setDataSources(newData)
    } else {
      newData.push({ id: guid(), ...values })
      setDataSources(newData)
      setEditData(null)
    }
  }

  const onClick = () => {
    setVisible(true)
    setInitData(null)
    setEditData(null)
  }

  return (
    <div style={{ marginBottom: 15 }}>
      <Button type="primary" onClick={onClick} style={{ marginBottom: 10 }}>{_t1('添加设备类型')}</Button>
      <DragSortingTable size="small"
        bordered setDataSources={setDataSources}
        dataSource={dataSource} columns={columns}
        pagination={false}
      />
      <KindModal
        initData={initData}
        setEditData={setEditData}
        visible={visible}
        setVisible={setVisible}
        data={dataSource}
        addWarningKind={addWarningKind}
      />
    </div>
  )
}

const KindModal = ({ visible, setVisible, addWarningKind, initData, setEditData, data }) => {
  const [values, setValue] = useState(null)
  const [disabled, setDisabled] = useState(false)
  const { t: _t1 } = useI18n()

  const handleOk = () => {
    if (values && values.name) {
      setVisible(false)
      addWarningKind(values)
    }
  }

  const onChange = (values) => {
    if (!values.name || values.name.indexOf(' ') != -1) {
      setDisabled(true)
    } else {
      //名称重复验证
      const datas = data.filter(item => item.name == values.name) || []
      if (initData && initData.name == values.name) {
        setDisabled(false)
        setValue(values)
      } else {
        if (datas.length > 0) {
          message.error('种类名称已存在')
          setDisabled(true)
        } else {
          setDisabled(false)
          setValue(values)
        }
      }
    }
  }

  const onCancel = () => {
    setVisible(false)
    setEditData(null)
  }

  return (
    <Modal
      title={_t1('种类信息')}
      visible={visible}
      onOk={handleOk}
      destroyOnClose
      okButtonProps={{ disabled }}
      onCancel={onCancel}
    >
      <C is="I18nSchemaForm" formKey={'WarningKinds'} schema={schema}
        onChange={onChange}
        initialValues={initData}
        component={FormLayout}
      />
    </Modal>
  )
}

const FormLayout = (props) => {
  const { children, handleSubmit } = props
  return <Form onSubmit={handleSubmit}> {children} </Form>
}

NodeKind.useGroup = false
export default {
  name: 'iot-NodeConfig',
  'settings.schema': app => (props, cb) => {
    cb(null, {
      name: 'nodeconfig',
      title: _r('设备类型'),
      parentTab: _r('设备配置'),
      parentIndex: 'modular',
      type: 'object',
      properties: {
        nodekind: {
          title: _r('设备类型'),
          type: 'array',
          items: {
            type: 'object',
            properties: {
              id: { title: 'id', type: 'string' },
              name: { title: _r('类型名称'), type: 'string' },
            },
          },
        }
      },
      form: [{ key: 'nodekind', component: NodeKind }],
    })
  }
}
