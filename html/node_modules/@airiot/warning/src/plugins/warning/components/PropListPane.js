import React from 'react';
import app, { use, api } from 'xadmin';
import { SchemaForm } from 'xadmin-form'
import { C } from 'xadmin-ui';
import _ from 'lodash';
import { Card, Tag, Select, Checkbox, Tooltip, Typography, InputNumber, Form } from 'antd';
import './../index.css'
const SlateEditor = ({ input: { onChange, value }, field, ...props }) => {
  // const { errorTips, parentSchema, hasLoading, systemVariable } = useSelectNode(value?.value)
  const [systemVariable, setSystemVariable] = React.useState([])
  let hasLoading = false; let parentSchema = []; let errorTips = []
  React.useEffect(() => {
    api({ name: 'core/systemVariable' }).query({ fields: ['type', 'value'], order: { createTime: 'DESC' } }, {}).then(({ items }) => {
      setSystemVariable(items)
    })
  }, [])

  return (
    <FlowSlateEditor errorTips={errorTips} parentSchema={parentSchema} hasLoading={hasLoading} systemVariable={systemVariable} value={value} onChange={onChange} field={field} {...props} ></FlowSlateEditor>
  )
}

const FlowSlateEditor = ({ errorTips, parentSchema, hasLoading, systemVariable, value, onChange, field, select, children }) => {

  const [panelVisible, setPanelVisible] = React.useState(false)

  const panelTargetRef = React.useRef(null)

  const valid = !(errorTips && errorTips.length > 0)

  const isBind = value && _.isPlainObject(value) && value.bind

  const nodeType = field?.extendFlow?.type

  const limit = nodeType ? null : (field?.limit || field?.extendFlow?.limit)

  const icon = require('./../../../icon/绑定.svg')

  const filterValue = (value, nodeType) => {
    if (value && value.length) {
      return value.filter(item => item.variable || item.text).map(item => {
        if (_.isString(item)) {
          return item
        } else if (item.text) {
          return item.text
        } else {
          const schemaItem = {
            defineSchema: {
              type: item.variable.type,
              format: item.variable.format
            },
            name: item.variable.title,
            value: item.variable.path,
            type: nodeType || item.variable?.defineSchema?.nodeType || item.variable.type
          }
          if (item.variable.path.indexOf('#$systemVariable') !== -1) {
            schemaItem.type = 'systemVariable'
          } else if (item.variable.path.indexOf('#$time') !== -1) {
            schemaItem.type = 'systemTime'
          }
          schemaItem.value = item.variable.path.replace && item.variable.path.replace(`.models`, '').replace(`.nodes`, '')
          return schemaItem
        }
      })
    }
    return null
  }

  const onSlateChange = initValue => {
    const value = filterValue(initValue?.origin, nodeType)
    if (value && value.length > 0) {
      if (select === 'single') {
        onChange({ bind: true, value: value[0], initValue: _.cloneDeep(initValue) })
      } else {
        onChange({ bind: true, value, initValue: _.cloneDeep(initValue) })
      }
    } else {
      onChange(null)
    }
  }

  let initValue = null

  if (value && _.isPlainObject(value) && value.bind) {
    initValue = value.initValue
  }

  const filterNodeType = (properties, nodeType) => {
    // if (!nodeType) return properties
    const typeMap = {
      tableData: {
        processName: '触发设备',
        groupName: '设备组',
        icon: ''
      },
      table: {
        processName: '触发设备表',
        groupName: '设备组',
        icon: ''
      },
      table: {
        processName: '触发工作表',
        groupName: '工作表组',
        icon: ''
      },
      user: {
        processName: '触发用户',
        groupName: '用户组',
        icon: ''
      },
      tableRecord: {
        processName: '触发工作表记录',
        groupName: '工作表记录组',
        icon: ''
      }
    }
    const _properties = {}
    for (let key of _.keys(properties)) {
      _properties[key] = _.cloneDeep(properties[key])
      const pItem = _properties[key]
      if (nodeType) {
        if (key === `#$${nodeType}`) {
          delete _properties[key].properties
        } else if (pItem.nodeType === nodeType) {
          for (let p of _.keys(_properties[key].properties)) {
            delete _properties[key].properties[p].properties
            _properties[key].properties[p].nodeType = nodeType
          }
        } else {
          delete _properties[key]
        }
      }
      if (typeMap[pItem.nodeType] && key.indexOf('#$') === -1) {
        pItem.title = typeMap[pItem.nodeType].groupName
        for (let p of _.keys(pItem.properties)) {
          if (pItem.properties[p].nodeType) {
            for (let subp of _.keys(pItem.properties[p].properties)) {
              pItem.properties[p].properties[subp].nodeType = pItem.properties[p].nodeType
            }
          }
          pItem.properties[p].nodeType = pItem.nodeType

        }
        delete pItem.nodeType
      }
      if (key.indexOf('#$') !== -1 && typeMap[key.replace('#$', '')]) {
        pItem.title = typeMap[key.replace('#$', '')].processName
        pItem.nodeType = key.replace('#$', '')
      }
    }
    return _properties
  }

  const getSchema = (parentSchema = [], systemVariable = [], nodeType) => {

    const finalSchema = {
      type: 'object',
      properties: {}
    }
    for (let schema of parentSchema) {
      const properties = filterNodeType(schema.properties, nodeType)
      if (!_.isEmpty(properties)) {
        finalSchema.properties[schema.id] = {
          title: schema.title,
          type: schema.type,
          properties: filterNodeType(schema.properties, nodeType)
        }
      }
    }
    if (!nodeType) {
      finalSchema.properties['#$systemVariable'] = {
        title: _r('系统变量'),
        type: 'object',
        properties: {}
      }
      finalSchema.properties['#$time'] = {
        title: _r('系统时间'),
        type: 'string',
        format: 'datetime'
      }
      for (let systemItem of systemVariable) {
        finalSchema.properties['#$systemVariable'].properties[systemItem.uid] = {
          title: systemItem.name,
          type: systemItem.type
        }
        if (systemItem.type === 'date') {
          finalSchema.properties['#$systemVariable'].properties[systemItem.uid].type = 'string'
          finalSchema.properties['#$systemVariable'].properties[systemItem.uid].format = 'datetime'
        }
      }
    }
    return finalSchema
  }

  const onClickPanel = () => {
    setPanelVisible(!panelVisible)
  }

  return (
    <>
      <div style={{ fontSize: 12, color: 'red' }}>{!valid ? '变量[ ' + errorTips.join(', ') + ' ] 已不存在' : null}</div>
      <div className="iot-flow-slate-editor-wrap" ref={panelTargetRef}>
        <div className="iot-flow-slate-editor-comp">
          {
            children && !isBind ? (
              <div>
                {children}
              </div>
            ) : null
          }
          <div className="iot-flow-slate-editor" style={{ display: children && !isBind ? 'none' : 'block' }}>
            <C
              is='CodeEditor.VariableEditor'
              schema={getSchema(parentSchema, systemVariable, nodeType) || []}
              placement="right"
              panelWidth={500}
              value={initValue}
              onChange={onSlateChange}
              limit={limit}
              nodeType={nodeType}
              select={select}
              hasLoading={hasLoading}
              panelVisible={panelVisible}
              panelTargetRef={panelTargetRef}
            />

          </div>
        </div>
        <div className="iot-flow-slate-editor-icon" style={{ width: '32px', height: '32px' }} dangerouslySetInnerHTML={{ __html: icon }} onClick={onClickPanel} />
      </div>
      {/* <C is='Dashboard.SlateEditor'
        field={field}
        valid={valid}
        value={initValue}
        showHandler={true}
        HandlerDom={props => <><ParamSelect
          {...props}
          limit={limit}
          loading={hasLoading}
          style={{ height: 32 }}
          systemVariable={systemVariable}
          parentSchema={parentSchema} /></>}
        onChange={onSlateChange} /> */}
      {/* <div className='dropdown-menu' style={{ position: 'relative' }}></div> */}
    </>
  )
}

const FlowData = props => {
  const { children, onChange, value, field, error } = props

  const onSelect = value => {
    const bindDate = { bind: true, value }
    onChange(bindDate)
  }

  const onClear = () => onChange(null)

  const extendFlow = field?.extendFlow

  const fieldType = field?.type

  const isExtend = extendFlow?.show

  const onlySelect = extendFlow?.onlySelect

  const mode = extendFlow?.mode ? extendFlow.mode : 'single'

  const isBind = value && _.isPlainObject(value) && value.bind

  let validValues = value

  if (isBind) {
    if (_.isPlainObject(value)) {
      const v2 = value.value
      if (_.isArray(v2)) validValues = v2
      if (_.isPlainObject(v2)) validValues = [v2]
    }
  }

  let errorTips = []
  const valid = !(errorTips && errorTips?.length > 0)

  const defaultChildren = onlySelect ? <Input placeholder={'仅支持变量'} disabled /> : children

  const onEditorChange = val => onChange(val)

  const singleChildren = (
    <SlateEditor input={{ onChange, value }} field={field} select="single">
      {defaultChildren}
    </SlateEditor>
  )

  const multipleChildren = (
    <>
      {/* <ErrorTip valid={valid} errorTips={errorTips} /> */}
      <SlateEditor input={{ onChange, value }} field={field} select="multiple">
        {defaultChildren}
      </SlateEditor>
    </>
  )

  const calculate = <SlateEditor input={{ onChange, value }} field={field} />

  let bindChildren = null

  if (fieldType == 'input') {
    bindChildren = calculate
  } else if (mode == 'multiple') {
    bindChildren = multipleChildren
  } else {
    bindChildren = singleChildren
  }

  return isExtend ? bindChildren : children
}

const FlowBindDataGroup = ({ label, meta, input, field, children }) => {
  const attrs = field.attrs || {}
  const error = meta.touched && (meta.error || meta.submitError)
  const extra = field.description || field.help
  const groupProps = { required: field.required }
  const size = (field.option && field.option.groupSize) || attrs.groupSize || {
    labelCol: { sm: { span: 24 } },
    wrapperCol: { sm: { span: 24 } }
  }

  const isBind = input?.value && _.isPlainObject(input.value) && input?.value?.bind
  // 非数据绑定显示错误信息
  if (!isBind && error) {
    groupProps['validateStatus'] = 'error'

    groupProps['help'] = error
  }
  const gProps = { ...groupProps, ...size, labelAlign: 'left' }
  const controlComponent = children ? children : (<Input {...input} {...attrs} />)

  return (
    <Form.Item label={label ?
      <>
        <span>{label}</span>
        {
          extra ? (
            <Tooltip placement="bottom" title={extra}>
              <QuestionCircleOutlined className="label-des" />
            </Tooltip>
          ) : null
        }
      </> : null
    } {...gProps}>

      <FlowData  {...input} {...attrs} field={field}>{controlComponent}</FlowData>
      {field.formText ? <span className="ant-form-text"> {field.formText}</span> : null}
    </Form.Item>
  )
}

const PropListPane = props => {

  const { input, field } = props
  const { form } = use('form')
  const type = 'number'

  let rules = form?.data?.warning?.rules
  let index = field?.key.substring(field?.key.indexOf('[') + 1, field?.key.lastIndexOf(']'))

  const dateObj = {}
  if (type === 'date') {
    dateObj.format = 'date'
  }
  if (type === 'number') {
    dateObj.fieldType = 'inputNumber'
  }

  const schema = {
    type: 'object',
    properties: {
      delay: {
        title: _r('延时提醒时长(s)'),
        type: 'number',
        minimum: 1,
        description: _r('若设置延时提醒时长，产生报警，经过设定时长后进行第一次报警提醒'),
        ...dateObj,
        field: {
          component: props => {
            const { input, type, select } = props
            const value = input.value
            const onChange = value => { input.onChange(value) }
            const defaultValue = value || _.isNumber(value) ? value : null
            return <InputNumber style={{ width: '100%' }} {...input} onChange={onChange} value={defaultValue} />
          },
          extendFlow: {
            show: true,
            limit: [type === 'date' ? 'time' : (type || 'string')]
          }
        }
      }
    }
  }

  const parse = (value) => {
    try {
      if (value || value === 0) {
        return JSON.parse(value)
      } else {
        return undefined
      }
    } catch {
      return value
    }
  }

  const onChange = values => input.onChange(values.delay)

  let initialValues = { delay: parse(input.value) }

  if (input?.value && _.isString(input.value)) { initialValues = { delay: rules[index]?.delaySetting } }

  return React.useMemo(() => {
    return <div className='delay-schema'><C is="I18nSchemaForm"
        formKey={`model.${JSON.stringify(type)}`}
        schema={schema}
        initialValues={initialValues}
        group={props => <FlowBindDataGroup {...props} label={null} />}
        component={({ children }) => children}
        onChange={onChange} />
      </div>
  }, [type])

}

export { PropListPane } 