import {
  atom, selector, RecoilRoot, selectorFamily, useRecoilState, useRecoilValue,
  useSetRecoilState, useRecoilCallback, useRecoilValueLoadable
} from 'recoil'
import { api, app, use } from 'xadmin'
import { message } from 'antd'
import produce from 'immer'
import _, { values } from 'lodash'
import { BadgeCountContext } from './apps/warning/pages/WarningInfoPage'

import {
  warningUnread,
  warningWsNewUnread,
  warningtypeCount,
  warningProcessedCount,
  warningCount,
  warningView,
  initWarning
} from './Store'
import React from 'react'

import rules from './plugins/warning/schema'

const mergeSchema = (newSchema, userExpand) => {
  for (let key of _.keys(userExpand?.properties || [])) {
    if (newSchema.properties && userExpand.properties) {
      newSchema.properties[key] = userExpand.properties[key]
      newSchema.form.push(key)
      if (newSchema.properties[key]?.filterFields) {
        newSchema.filters.submenu.push(key)
      }
    }
  }
  return newSchema
}

const atomsCache = new Map()

const selectorCreator = (recoilState, path) => {
  if (!recoilState) {
    return
  }
  const key = `selector.${recoilState?.key}${path ? '.' + path : ''}`
  if (atomsCache.has(key)) {
    return atomsCache.get(key)
  } else {
    const atomSelector = selector({
      key,
      get: ({ get }) => {
        const state = get(recoilState)
        if (path) return _.get(state, path)
        return state
      },
      set: ({ set, get }, newValue) => {
        const state = get(recoilState)
        let newState = newValue
        if (path) {
          newState = _.set({ ...state }, path, newValue)
        }
        return set(recoilState, newState)
      }
    })
    atomsCache.set(key, atomSelector)
    return atomSelector
  }
}

function useAtomState() {
  return useRecoilState(selectorCreator(...arguments))
}
function useAtomValue() {
  return useRecoilValue(selectorCreator(...arguments))
}
function useAtomSet() {
  return useSetRecoilState(selectorCreator(...arguments))
}

const getWarningStat = () => {
  return api({ name: `warning/warning/stats` }).fetch('', {}).then(({ json }) => json).catch(err => { return [] })
}
const warningStatSelector = selectorFamily({
  key: 'warningStatSelector',
  get: (query) => async ({ get }) => {
    let warningStat = await getWarningStat()
    return warningStat || []
  }
})

const warningData = selectorFamily({
  key: 'warning_data_selector',
  get: (query) => async () => {
    let newState = {}
    try {
      const items = await api(app.get('models').Warning).fetch('/stats/latest').then(({ json }) => json)
      const typeCount = items?.length
      const wheres = { withoutBody: true }
      const processedWheres = { "filter": { "processed": "未处理" }, withoutBody: true }

      const waringsCount = await api(app.get('models').Warning).fetch(`?query=${JSON.stringify(wheres)}`).then(res => {
        return res?.headers?.count - 0
      })
      const processedCount = await api(app.get('models').Warning)
        .fetch(`?query=${JSON.stringify(processedWheres)}`)
        .then(res => {
          return res?.headers?.count - 0
        })
      newState = { unread: items, typeCount, count: waringsCount, processedCount }
    } catch (err) {
      app.error(err)
    }
    return newState
  }
})

const warning_confirm_batch = selectorFamily({
  key: 'warning_confirm_batch_selector',
  get: path => ({ get }) => {
    return []
  },
  set: path => ({ set, get }, newValue) => {
    const { type, filter, ids, getItems } = path || newValue
    try {
      const { Warning } = app.get('models')

      const batchAction = type == '@@oilive/CONFIRM_BATCH_WARNING' ? '?type=status' : '?type=processed'
      api({ name: 'warning/warning/batch' }).fetch(batchAction, {
        method: 'PATCH',
        body: JSON.stringify(ids)
      }).then(res => {
        if (res.status == 200) {
          message.success('批量确认报警信息成功')
        }
        getItems()
      })
      // console.log(newWarn, 98)
      // yield put({ type: 'GET_ITEMS', model: { ...Warning, key: 'warning' } })
      // const ws = yield select(state => state.model.Warning)
      // const wbs = yield select(state => state.model.warning_bar)
      // const user = yield select(state => state.user)
      // if (ws && ws.ids && ws.items) {
      //   yield Object.values(ws.items).map(item => put({
      //     model: { key: 'Warning' },
      //     type: 'SAVE_ITEM', success: true,
      //     item: { ...item, user, ...result }
      //   }))
      // }
      // if (wbs && wbs.ids && wbs.items) {
      //   yield Object.values(wbs.items).map(item => put({
      //     model: { key: 'warning_bar' },
      //     type: 'SAVE_ITEM', success: true,
      //     item: { ...item, user, ...result }
      //   }))
      // }
      // yield handle_unread_warning()
      const state = get(initWarning)
      let newState = newValue
      if (path) {
        newState = produce(state, draft => {
          _.set(draft, path, newValue)
        })
      }
      return set(initWarning, newState)

    } catch (err) {
      // message.error('操作出现问题')
      // app.error(err)
    }

    // const state = get(cellDisplay)
    // let newState = newValue
    // if (payload) {
    //   newState = _.set(_.cloneDeep(state), path, newValue)
    // }
    // set(historySelector, 'display')
    // return set(cellDisplay, newState)
  }
})

const confirm_all_warning = selectorFamily({
  key: 'confirm_all_warning_selector',
  get: path => ({ get }) => {
    return []
  },
  set: path => ({ set, get }, newValue) => {
    let getItems = () => null
    try {
      getItems = use('model.getItems', props)?.getItems
    } catch { }
    try {
      const where = path || newValue?.type
      let warningAll = api({ name: 'warning/warning/all' }).fetch('', {
        method: 'PATCH',
        body: JSON.stringify(where)
      }).then(res => {
        if (res.status == '200') {
          message.success('成功确认全部报警信息')
        }
      })
      set(warningUnread, [])
      set(warningWsNewUnread, [])
      set(warningtypeCount, 0)
      set(warningProcessedCount, 0)
      getItems()
      // const warning_bar = yield select(state => state && state.model && state.model.warning_bar)
      // if (warning_bar && warning_bar.items && warning_bar.ids) {
      //   yield put({
      //     model: { key: 'warning_bar' },
      //     type: 'GET_ITEMS',
      //     success: true,
      //     items: warning_bar?.ids?.map(id => ({ ...warning_bar?.items[id], status: '已确认' }))
      //   })
      // }
    } catch (err) {
      message.error('操作出现问题')
      app.error(err)
    }
    return
  }
})

const processed_all_warning = selectorFamily({
  key: 'processed_all_warning_selector',
  get: path => ({ get }) => {
    return []
  },
  set: path => ({ set, get }, newValue) => {
    let getItems = () => null
    let type = path || newValue?.type
    try {
      getItems = use('model.getItems', props)?.getItems
    } catch { }
    try {
      let warningAll = api({ name: 'warning/warning/all' }).fetch(`?type=${type}`, {
        method: 'PATCH',
      }).then(res => {
        if (res.status == '200') {
          message.success('成功处理全部报警信息')
        }
      })
      set(warningWsNewUnread, [])
      getItems()
    } catch (err) {
      message.error('操作出现问题')
      app.error(err)
    }
    return
  }
})


const warningAddData = selectorFamily({
  key: 'warning_add_data_selector',
  get: path => async ({ get }) => {
    let newState = {}
    return newState
  },
  set: path => ({ set, get }, newValue) => {
    // const { atoms } = use('model')
    const state = get(warningUnread)
    const processedCount = get(warningProcessedCount)
    const count = get(warningCount)
    const unread = get(warningUnread)
    const wsWarnings = get(warningWsNewUnread)
    const typeCount = get(warningtypeCount)
    let newState = newValue
    let hasType;

    if (path) {
      newState = _.merge(_.cloneDeep(state), path)
      hasType = unread.some(w => w?.tableData?.id == path?.tableData?.id && w?.ruleid == path?.ruleid)
    } else {
      newState = _.merge(_.cloneDeep(state), newValue)
      hasType = unread.some(w => w?.tableData?.id == newValue?.tableData?.id && w?.ruleid == newValue?.ruleid)
    }

    // 更新卡片列表
    //   const warning_bar = yield select(state => state && state.model && state.model.warning_bar)
    //   if (warning_bar && warning_bar.items && warning_bar.ids) {
    //     yield put({
    //       model: { key: 'warning_bar' },
    //       type: 'GET_ITEMS', success: true,
    //       items: [{
    //         id: Math.random() * 1000,
    //         ...payload
    //       }, ...warning_bar.ids.slice(0, 30).map(id => warning_bar.items[id])]
    //     })
    //   }
    console.log(warningCount, warningProcessedCount, '更新报警数量')
    // 更新报警总数 
    set(warningProcessedCount, processedCount + 1)
    set(warningCount, count + 1)
    //更新报警种类总数
    if (!hasType) set(warningtypeCount, typeCount + 1)
    // ws报警
    set(warningWsNewUnread, [...wsWarnings, newValue])
    return set(warningUnread, [...unread, newValue])
  }
})

export default {
  'warning.stat': () => useAtomState(warningStatSelector()),
  'warning.confirm.batch': path => useAtomState(warning_confirm_batch(path)),
  'warning.processed.all': path => useAtomState(processed_all_warning(path)),
  'warnings.confirmall': path => useAtomState(confirm_all_warning(path)),
  'warning.unread': () => useAtomState(warningUnread),
  'warning.count': () => useAtomState(warningCount),
  'warning.typeCount': () => useAtomState(warningtypeCount),
  'warning.processedCount': () => useAtomState(warningProcessedCount),
  'warning.add': path => useAtomState(warningAddData(path)),
  'warnings.confirm': () => {
    const { user } = use('auth.user')
    const { Warning } = app.get('models')
    // const { getItems } = use('model.getItems')
    // const { saveItem } = use('model.save')
    // const setCount = use('warning.tabBadge')
    const confirm = async (item) => {
      let result = api(Warning).save({ id: item?.id, status: '已确认', confirmUser: { id: user?.userId, name: user?.username } }, true).then(res => res)
      const confirmItem = { confirmUser: { id: user?.userId, name: user?.username }, ...result }
      // saveItem({ id: item?.id, item: confirmItem  })
      // getItems()
      // if (result) {
      //   message.success('报警信息已确认')
      //   item.processed == '已处理' && setCount && setCount()
      // }
      return result
    }
    const onProcessed = async (item) => {
      const result = api(Warning).save({ id: item?.id, processed: '已处理', handleUser: { id: user?.userId, name: user.username } }, true).then(res => res)
      const confirmItem = { handleUser: { id: user?.userId, name: user.username }, ...result }
      // saveItem({ id: item?.id, item: confirmItem  })
      // getItems()
      // if (result) {
      //   message.success('成功处理报警信息')
      //   item.status == '已确认' && setCount && setCount()
      // }
      // yield put({ type: 'SAVE_ITEM', model: Warning, item, partial: true, success: true })
      // yield put({ type: 'SAVE_ITEM', model: { key: 'warning_bar' }, item, partial: true, success: true })
      return result
    }

    return { confirm, onProcessed }
  },
  'warning.ws': (where = {}, init = true, initwheres = {}, dataType = null, limit) => {
    const [dataSource, setDataSource] = React.useState([])
    const { settings } = use('settings')
    const warning = settings?.warning
    const { onData, subscribe } = use('ws')
    const [unread, setUnread] = use('warning.unread')
    const unsubscribe = React.useRef()

    React.useEffect(() => {
      if (init) {
        let query = {
          sort: { time: -1 },
          skip: 0,
          limit: limit || 15,
          project: {
            status: 1, processed: 1, uid: 1, tableDataId: 1, handle: 1, time: 1, table: 1, tableData: 1, department: 1,
            fields: 1, level: 1, type: 1, confirmUser: 1, desc: 1, remark: 1, 'tableData._settings': 1, 'tableData.hkvideo': 1, recoveryTime: 1
          },
          withCount: true
        }
        if (!_.isEmpty(initwheres)) query.filter = initwheres.filter
        const querystr = encodeURIComponent(JSON.stringify(query))
        api({ name: `warning/warning?query=${querystr}` })
          .fetch('', {})
          .then(({ json }) => {
            setDataSource(json)
            if (unsubscribe?.current && _.isFunction(unsubscribe.current)) unsubscribe.current()
            return unsubscribe.current = subscribe('warning', where)
          })
      } else {
        if (unsubscribe?.current && _.isFunction(unsubscribe.current)) unsubscribe.current()
        return unsubscribe.current = subscribe('warning', where)
      }
    }, [JSON.stringify(where), init, JSON.stringify(initwheres), JSON.stringify(limit)])

    React.useEffect(() => {
      // 卸载时取消订阅
      return () => {
        if (unsubscribe?.current && _.isFunction(unsubscribe.current)) unsubscribe.current()
      }
    }, [])

    const toFixed = (Dight, How = 2) => {
      return _.isNumber(Dight) ? Math.round(Dight * Math.pow(10, How)) / Math.pow(10, How) : Dight
    }

    const toValue = (value, fixed) => {
      return _.isBoolean(value) ?
        (value ? 1 : 0) :
        (_.isNumber(value) ?
          toFixed(value, fixed !== undefined ? fixed : 3) :
          (value ? value.toString() : '-')
        )
    }

    const renderValue = (val) => {
      return val.fields ? val.fields.map(item => {
        const value = toValue(item.value, item?.fixed) + `${item?.unit || ''}`

        return (item?.name && item?.value != undefined) ? <span style={{ marginRight: 5, cursor: 'pointer' }} onClick={() => {
          if (node) {
            onShow({ time, node, tag: item })
          }
        }}>{item.name}:{value}</span> : ''
      }).filter(Boolean) : ''
    }

    onData(data => {
      if (data && _.isPlainObject(data) && !data?.recoveryTime) {
        if (dataType == 'realtime') {
          let dataJson = _.cloneDeep(dataSource) || []
          if (dataSource?.length < limit) {
            _.isArray(dataJson) && dataJson.unshift(data)
          } else {
            _.isArray(dataJson) && dataJson.unshift(data)
            dataJson.pop()
          }
          let newData = dataJson.map(val => {
            return {
              ...val,
              time: moment(val.time).format('YYYY-MM-DD HH:mm:ss'),
              fields: renderValue(val),
              type: warning?.warningkind?.length ? warning.warningkind.filter(i => { return val.type == i.id })[0]?.name : ''
            }
          })
          setDataSource(newData)
        } else {
          setUnread([...unread, data])
          setDataSource([...dataSource, data])
        }
      }
    })

    return { data: dataSource }
  },
  'warning.data': async () => {
    const [typeCount, setTypeCount] = use('warning.typeCount')
    const [count, setCount] = use('warning.count')
    const [processedCount, setProcessedCount] = use('warning.processedCount')

    let newState = {}
    try {
      const items = await api(app.get('models').Warning).fetch('/stats/latest').then(({ json }) => json)
      const typeCount = items?.length
      const wheres = { withoutBody: true }
      const processedWheres = { "filter": { "processed": "未处理" }, withoutBody: true }

      const waringsCount = await api(app.get('models').Warning).fetch(`?query=${JSON.stringify(wheres)}`).then(res => {
        return res?.headers?.count - 0
      })
      const processedCount = await api(app.get('models').Warning)
        .fetch(`?query=${JSON.stringify(processedWheres)}`)
        .then(res => {
          return res?.headers?.count - 0
        })
      newState = { unread: items, typeCount, count: waringsCount, processedCount }
      setTypeCount(typeCount)
      setCount(waringsCount)
      setProcessedCount(processedCount)
    } catch (err) {
      app.error(err)
    }

    return newState
  },
  'warning.schema': (table, tableData) => {
    return { rules: rules({ table, tableData }) }
  },
  'warning.warningExpand': props => {
    const { schema } = props
    const { settings } = use('settings')
    const warningExpand = settings?.warning?.warningExpand

    let newSchema = mergeSchema(schema, warningExpand)
    return newSchema
  },
  'warning.tabBadge': () => {
    const setCount = React.useContext(BadgeCountContext)
    return setCount
  }
}

export { warningStatSelector }