import React, { useMemo } from 'react'
import _ from 'lodash'
import { app, Block, use } from 'xadmin'
import { _t } from 'xadmin-i18n'
import { SchemaForm } from 'xadmin-form'
import { C, Loading, Icon } from 'xadmin-ui'
import { Table, Tooltip, Empty, Menu, Dropdown, Form, List, Card, Button, Popconfirm, Checkbox, Popover } from 'antd'
import { useRecoilValue, useRecoilState } from 'recoil'

const getFieldProp = (model, field) => {
  return field.split('.').reduce((obj, f) => {
    return obj && obj.properties && obj.properties[f]
  }, model)
}

const ItemEditFormLayout = (props) => {
  const { children, pristine, invalid, handleSubmit, submitting } = props
  return (
    <Form onSubmit={handleSubmit}>
      {children}
      <Button style={{ marginTop: '-1rem' }} block type="submit" loading={submitting} disabled={pristine || invalid} size="small" onClick={handleSubmit}>{_t('Change')}</Button>
    </Form>
  )
}

const ItemEditForm = props => {
  const { item, field, schema, model, onClose, saveItem } = use('model.save', props)

  const formField = _.find(model.form || [], obj => obj && obj.key == field) || { key: field }
  const required = (model.required || []).indexOf(field) >= 0 ? { required: [field] } : {}

  return (
    <C is="I18nSchemaForm" formKey="ChangeDataForm"
      initialValues={item}
      schema={{
        type: 'object',
        properties: {
          [field]: schema
        },
        form: [formField],
        ...required
      }}
      option={{ group: C('Form.InlineGroup') }}
      onSubmit={(values) => saveItem({ ...values, __partial__: true })}
      onSubmitSuccess={() => onClose()}
      component={ItemEditFormLayout} />
  )
}

const Item = props => {
  const { value, field, schema, componentClass, wrap, editable, ...itemProps } = use('model.list.item', props)
  const { item } = props
  const [edit, setEdit] = React.useState(false)
  // console.log(item, use('model.list.item', props), 53)
  const RawWrapComponent = wrap || 'span'
  const WrapComponent = editable ? RawWrapComponent : ({ children, ...props }) => {
    return (
      <Popover content={(<ItemEditForm item={item} field={field} schema={schema} onClose={() => setEdit(false)} />)}
        trigger="click" onVisibleChange={setEdit} visible={edit} placement="right" >
        <RawWrapComponent {...props} style={{ cursor: 'pointer' }}>{children}</RawWrapComponent>
      </Popover>
    )
  }

  if (item == undefined || item == null) {
    return <WrapComponent><span className="text-muted">{_t('Null')}</span></WrapComponent>
  }

  if (componentClass) {
    const ItemComponent = componentClass
    return <ItemComponent item={item} value={value} field={field} schema={schema} wrap={WrapComponent} {...itemProps} />
  } else {
    return <WrapComponent>{value == undefined || value == null ? <span className="text-muted">{_t('Null')}</span> : value}</WrapComponent>
  }

}

const Header = props => {
  const { title, order, showText, canOrder, changeOrder } = use('model.list.header', props)

  const renderOrder = () => {
    let orderItems = []

    if (canOrder) {
      orderItems = [
        <Menu.Item onClick={e => { changeOrder('ASC') }} key="ASC"><Icon type="caret-up" /> {_t('Sort ASC')}</Menu.Item>,
        <Menu.Item onClick={e => { changeOrder('DESC') }} key="DESC"><Icon type="caret-down" /> {_t('Sort DESC')}</Menu.Item>
      ]
      if (order != '') {
        orderItems.push(<Menu.Item onClick={e => { changeOrder('') }}><Icon type="close" /> {_t('Clear order')}</Menu.Item>)
      }
    }
    return orderItems
  }
  const icon = {
    'ASC': <Icon type="caret-up" />,
    'DESC': <Icon type="caret-down" />
  }[order] || ''
  const items = [...renderOrder(), ...(Block('model.list.header.menu') || [])]

  return (items.filter(item => !_.isNil(item)).length > 0) ? (
    <Dropdown overlay={(
      <Menu selectedKeys={[order]}>{React.Children.toArray(items)}</Menu>
    )} trigger={['click']}>
      <a style={{ cursor: 'pointer' }}>{title} {icon}</a>
    </Dropdown>
  ) : (showText === false ? null : <span>{title} {icon}</span>)

}

const useActions = props => {
  const { renderActions } = use('model.actions')
  const { atoms } = use('model')
  const fields = useRecoilValue(atoms.fields)
  let recoveryAction;
  if (fields?.indexOf('recoveryTime') == -1) {
    recoveryAction = renderActions(props)
  } else {
    recoveryAction = renderActions(props).length > 3 ? renderActions(props).splice(2, 3) : renderActions(props)
  }
  return <Button.Group size="small" className="model-list-action">{recoveryAction}</Button.Group>
}

const useList = render => props => {
  const state = use('model.list', use('model', props))
  const { model } = use('model')
  const { loading, items } = state
  const list = render(state)

  if (loading) {
    return <Loading>{items.length > 0 ? list : null}</Loading>
  } else {
    if (items.length > 0) {
      return list
    } else {
      const EmptyComponent = model?.components && model?.components.DataEmpty
      if (EmptyComponent) {
        return <EmptyComponent />
      } else {
        return <C is="NoData" />
      }
    }
  }
}

const DataTableActionRender = props => {
  return <div style={{ width: '100%', textAlign: 'center' }}>{useActions(use('model.list.row', props))}</div>
}

const DataTable = useList(({ items, fields, size, onRow, tableProps }) => {
  const { model, atoms } = use('model')
  const { actions } = use('model.actions')
  const { actions: batchActions } = use('model.batchActions')
  const { selected, onSelect, onSelectAll } = use('model.select')

  const [option, setOption] = useRecoilState(atoms.option)

  const lockedFields = model?.lockedFields || []
  const columns = []
  fields && fields.forEach((fieldName) => {
    const field = getFieldProp(model, fieldName)
    if (fieldName == 'recoveryTime') {
      columns.push({
        width: 200,
        key: fieldName,
        dataIndex: fieldName,
        title: _r('恢复时间'),
        render: (value, item) => {
          return moment(value).format('YYYY-MM-DD HH:mm:ss')
        }
      })
    }
    if (!field) return

    const column = {
      field,
      width: field.width || '',
      fixed: lockedFields?.indexOf(fieldName) >= 0,
      title: <Header key={`model-list-header-${fieldName}`} field={fieldName} />,
      key: fieldName,
      dataIndex: fieldName,
      render: (value, item) => {
        return <Item item={item} field={fieldName} />
      },
      ...field.column
    }
    if (field.level2) {
      if (columns.length > 0 &&
        columns[columns.length - 1].children !== undefined &&
        columns[columns.length - 1].title == field.level2) {
        columns[columns.length - 1].children.push(column)
      } else {
        columns.push({
          title: field.level2,
          children: [column]
        })
      }
    } else {
      columns.push(column)
    }
  })

  if (actions && actions.length > 0)
    columns.push({
      title: '',
      width: 380,
      fixed: 'right',
      key: '__action__',
      render: (val, item) => <DataTableActionRender key={item.id} fields={fields} id={item.id} />
    })

  const rowSelection = batchActions && batchActions.length > 0 ? {
    selectedRowKeys: selected.map(r => r.id),
    onSelect, onSelectAll,
    // 报警归档多选处理
    getCheckboxProps: record => model?.key == 'warning' ? ({
      disabled: (record?.processed == '已处理' && record?.status == '已确认') || ('handle' in record && record?.handle == false)
    }) : ({})
  } : undefined
  // 计算scrollX
  const scrollX = useMemo(() => {
    const fieldsLenght = columns && columns.length
    const lenghtX = fieldsLenght * 85
    const offsetX = columns && columns.length > 0 && columns.map(item => item.width - 80 || 0).reduce((total, num) => total + num) || 0
    return lenghtX + offsetX
  }, [columns])

  return (
    <Table
      columns={columns}
      dataSource={items}
      bordered
      size={option?.size || size || 'middle'}
      rowSelection={rowSelection}
      pagination={false}
      onRow={onRow}
      rowKey="id"
      {...tableProps}
      scroll={{ x: scrollX }}
    />
  )
})

export default DataTable
